/**
 * Referme les coffres utilisés
 * Octroit un bonus temporaire à l'ouverture d'un coffre
 */

var O2 = require('o2');
var Mediator = require('mediator');
var Plugin = Mediator.Plugin;
var u = require('mwgame/Utils.js');

var LOOT = require('mwgame/data/loot.js');

var ModChests = O2.extendClass(Plugin, {
	
	aChestRegister: null,
	aLootData: null,
	aChestCodes: null,
	
	CHEST_RESEED_TIME: 60, // ouvert pendant une minute
	
	getName: function() {
		return 'ModChests';
	},
	
	buildLootData: function(sType) {
		var l = [];
		var i;
		for (var sLoot in LOOT[sType]) {
			for (i = 0; i < LOOT[sType][sLoot]; ++i) {
				l.push(sLoot);
			}
		}
		this.aLootData[sType] = l;
	},
	
	init: function() {
		this.aLootData = {};
		this.aChestRegister = [];
		Object.keys(LOOT).forEach(function(sType) {
			this.buildLootData(sType);
		}, this);
		this.register('instanceCreated');
		this.register('entityActivateWall');
		this.register('generateLoot');
		this.register('timeSecond');
	},
	
	instanceCreated: function(oInstance) {
		this.aChestRegister[oInstance.getId()] = {};
		// rechercher quel est le code correspondant au coffre ouvert
		var x, y, l = oInstance.getMapSize();
		var sTag, aTag, sCheckTag, sOption, sValue, bChestPresent = false;
		this.aChestCodes = [];
		for (y = 0; y < l; ++y) {
			for (x = 0; x < l; ++x) {
				sTag = oInstance.getMapBlockProp(x, y, 'tag');
				if (typeof sTag === 'string') {
					aTag = sTag.split(' ');
					sCheckTag = aTag.shift();
					sOption = aTag.shift();
					sValue = aTag.join(' ');
					if (sCheckTag === 'chest-config') {
						switch (sOption) {
							case 'states': // défini le code de coffre ouvert et fermé
								this.aChestCodes[aTag[0] | 0] = aTag[1] | 0;
							break;
						}
					} else if (sCheckTag === 'chest') {
						bChestPresent = true;
					}
				}
			}
		}
		if (bChestPresent && this.aChestCodes.length === 0) {
			// Use map tag "chest-config states (close) (empty)" to define open and close chest code
			throw new Error('ModChest error ! No close-and-empty states defined.');
		}
	},
	
	generateLoot: function(oInstance, oParams) {
		var sType = oParams.t;
		oParams.i = u.choose(this.aLootData[sType]);
	},
	
	entityActivateWall: function(oInstance, oParams) {
		var oEntity = oParams.e;
		var x = oParams.x;
		var y = oParams.y;
		var aTags = oParams.t.split(' ');
		if (aTags.length === 0) {
			return;
		}
		var sTag = aTags[0];
		var sType = aTags[1] || 'normal';
		var nPick = 1;
		var nLuck = oEntity.getSoul().getAttribute('luck');
		if (nLuck > 0) {
			if (u.prob(nLuck)) {
				++nPick;
			}
		} else if (nLuck < 0) {
			if (u.prob(-nLuck)) {
				--nPick;
			}
		}
		if (sTag === 'chest' && !this.isChestOpen(oInstance, x, y)) {
			var oPickup = {i: [], e: oEntity, f: false};
			var oLootEvent = {t: sType, i: null};
			while (nPick > 0) {
				// donner un objet à l'entité
				this.generateLoot(oInstance, oLootEvent);
				oPickup.i.push(oLootEvent.i);
				--nPick;
			}
			oInstance.sendSignal('entityPickUpItem', oPickup);
			if (!oPickup.f) {
				this.openChest(oInstance, x, y, oInstance.getTime() + this.CHEST_RESEED_TIME);
			}
		}
	},
	
	timeSecond: function(oInstance) {
		var nTime = oInstance.getTime();
		var cr = this.aChestRegister[oInstance.getId()];
		var x = '', y = '', cry;
		// parcourir le registre
		for (y in cr) {
			cry = cr[y];
			for (x in cry) {
				if ((cry[x] !== null) && (nTime > cry[x].until)) {
					// refermer ce coffre
					this.closeChest(oInstance, x, y);
				}
			}
		}
	},
	
	isChestOpen: function(oInstance, x, y) {
		var cr = this.aChestRegister[oInstance.getId()];
		if (y in cr) {
			return !!cr[y][x];
		}
	},

	/**
	 * Ouverture d'un coffre
	 * AU niveau visuel l'ouverture d'un coffre revien à augmenter le code
	 * texture de 1 car ici on considère que la texture du coffre ouvert
	 * est juste après la texture du coffre fermé.
	 * il est difficile d'ajouter une structure de donnée permettant 
	 * de décrire les deux état d'un coffre
	 * @param oInstance
	 * @param int x
	 * @param int y position du coffre
	 * @param int nUntil timestamp a partir duquel le coffre se referme
	 */
	openChest: function(oInstance, x, y, nUntil) {
		var cr = this.aChestRegister[oInstance.getId()];
		if (!(y in cr)) {
			cr[y] = {};
		}
		var cry = cr[y];
		if (!cry[x]) {
			var nCode = oInstance.getMapBlockCode(x, y);
			cry[x] = {
				until: nUntil,
				code: nCode
			}
			oInstance.setMapBlockCode(x, y, this.aChestCodes[nCode], 'CHEST_OPEN');
		} // sinon : déja ouvert
	},
	
	/** 
	 * Fermeture d'un coffre
	 * (diminution du code texture de 1)
	 * @param oInstance 
	 * @param x
	 * @param y position du coffre
	 */
	closeChest: function(oInstance, x, y) {
		var nCode = this.aChestRegister[oInstance.getId()][y][x].code;
		this.aChestRegister[oInstance.getId()][y][x] = null;
		oInstance.setMapBlockCode(x, y, nCode, 'CHEST_CLOSE');
	}
});

module.exports = ModChests;
