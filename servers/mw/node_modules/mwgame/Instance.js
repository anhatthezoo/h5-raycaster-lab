/**
 * Classe Instance
 * Gestion d'une partie (le monde et la totalité des objets ou entités qui sont dedans)
 */

var O2 = require('o2');
var fs = require('fs');
var BLUEPRINTS = require('./data/blueprints.js');
var Mapper = require('./Mapper.js');
var Entity = require('./Entity.js');
var EntityHorde = require('./EntityHorde.js');

var Items = require('./Items.js');
var Soul = require('./Soul.js');
var EffectProcessor = require('./EffectProcessor.js');
var Effect = require('./Effects.js');
var Snail = require('./SquareSnail.js');
var u = require('./Utils.js');

var CONST = require('./data/consts.js');
var ATTR = require('./data/attributes.js');




var Instance = O2.createClass({

	_nTimeMod: 0, // Tempus fugit
	_nTime: 0, // Tempus fugit
	
	_oMapper: null,  // Mapper Object 
	
	_id: 0, // identifiant de l'instance
	_oLevel: null, // données concernant le monde
	_aMapProp: null, // données concernant les blocks composant le monde
	_sName: '', // nom de l'instance (map1, dungeon8)
	
	_aClients: null, // liste des clients connecté a l'instance
	_aSockets: null, // liste d'acces rapide au sockets
	_aClientEntities: null, // liste des entité controllée par client
	_bAllReady: false, // indique que tous les client sont  pret
	_bStating: false,
	_bTerminate: false, // gives the order to terminate
	
	_oTags: null, // liste des tags groupé par mot clés
	_oSpawnPoints: null, // liste des points de respawn
	_aOpenDoors: null,	
	_aOpenSecretDoors: null,	
	_oHorde: null,
	_oEffectProcessor: null,
	_aMailBox: null, // Permet aux plugin de poster des messages reseaux ['XX', [destinaires (entité)], oData]
	
	_nPlaneSpacing: 64,
	
	onSignal: null,
	onEntityKilled: null,
	onEntitySpawn: null,
	onEntityRespawn: null,
	onMapModification: null,
	onCloseDoor: null,
	onOpenDoor: null,	
	onDestroyEntity: null,
	onMapChange: null,
	onLaunchMissiles: null,
	onNetworkMessage: null,
	onLogMessage: null,
	onEnd: null,
	
	boundEntityEnteringSector: null,
	boundEntityLeavingSector: null,
	boundSoulAttributeChanged: null,
	
	__construct: function() {
		this._oMapper = Mapper;
		this._aClients = [];
		this._oHorde = new EntityHorde();
		this._oEffectProcessor = new EffectProcessor();
		this._aMailBox = [];
		this.boundEntityEnteringSector = this.entityEnteringSector.bind(this);
		this.boundEntityLeavingSector = this.entityLeavingSector.bind(this);
		this.boundSoulAttributeChanged = this.soulAttributeChanged.bind(this);
	},
	
	
	reset: function() {
		this._nTimeMod = 0;
		this._nTime = 0;
		this._oLevel = null;
		this._aMapProp = null;

		this._bAllReady = false;
		this._bStating = false;
	
		this._oTags = null;
		this._oSpawnPoints = null;
		this._aOpenDoors = null;	
		this._aOpenSecretDoors = null;	
		this._oHorde.clear();
		this._oEffectProcessor.reset(),
		this._aMailBox = [];
		this._bTerminate = false;
	},

	/**
	 * Terminates the instance.
	 * however instances should not self-terminate
	 * so the MWGame is in charge to terminate them
	 * this function only set flag
	 * @param string m last message to send to clients
	 */
	terminate: function(m) {
		this._bTerminate = true;
	},
	
	/**
	 * Return true if the instance is flagged as "terminating"
	 */
	isTerminated: function() {
		return this._bTerminate;
	},
	
	
	getTime: function() {
		return this._nTime;
	},
	/**
	 * getter / setter nom de la partie
	 */
	setName: function(n) {
		this._sName = n;
	},

	getName: function(n) {
		return this._sName;
	},
	
	logMessage: function() {
		if (this.onLogMessage) {
			this.onLogMessage(this, Array.prototype.slice.call(arguments, 0).join(' '));
		}
	},
	
	/**
	 * getter / setter identifiant partie
	 */
	setId: function(id) {
		this._id = id;
	},
	
	getId: function() {
		return this._id;
	},
	
	/**
	 * Reconstruit rapido le tableau de sockets
	 */
	buildSockets: function() {
		var aClients = this._aClients.filter(function(c) {
			return !!c;
		});
		this._aSockets = aClients.map(function(c) {
			return c.getSocket();
		});
	},
	
	/**
	 * Fabrique la liste des entités associées aux client
	 * Cette liste sera dispo via getClientEntities()
	 * Pour retrouver rapidement toutes les entité qui sont 
	 * liée à un client
	 */
	buildClientEntities: function() {
		var aClients = this._aClients.filter(function(c) {
			return (!!c) && (!!c.getEntity());
		});
		this._aClientEntities = aClients.map(function(c) {
			return c.getEntity();
		});
	},
	
	pushNetworkMessage: function(aEntities, oData) {
		this._aMailBox.push([aEntities, oData]);
	},

	popNetworkMessage: function() {
		return this._aMailBox.shift();
	},
	
	updateHud: function(aEntities, idHud) {
		var aArgs = Array.prototype.slice.call(arguments, 2);
		this.pushNetworkMessage(aEntities, {m: 'hud', h: idHud, d: aArgs});
	},

	
	/**
	 * renvoie true si le client est noté comme "pret" à recevoir des message réseau
	 * de mise à jour des autres clients 
	 * @return bool
	 */
	testClientReady: function(c) {
		return c.isReady();
	},
	
	/**
	 * Renvoie les sockets des client connecté à l'instance
	 * @return arrray of socket
	 */
	getSockets: function() {
		if (this._bAllReady) {
			return this._aSockets;
		} else {
			var tcr = this.testClientReady;
			// si certain client n'etaient pas prêts on
			// reverifie s'il sont pret maintenant
			this._bAllReady = this._aClients.every(tcr);
			if (this._bAllReady) {
				return this._aSockets;
			} else {
				return this._aClients.filter(tcr).map(function(c) {
					return c.getSocket();
				});
			}
		}
	},

	/**
	 * Ajout d'un client à la partie, enregistrement de l'entité associée
	 * @param Client c
	 */
	addClient: function(c) {
		if (this._aClients.indexOf(c) < 0) {
			this._aClients.push(c);
			c.setInstance(this);
			this._bAllReady = false;
			this.buildSockets();
		} else {
			throw new Error('client #' + c.getId() + ' already in game');
		}
	},
	
	/**
	 * Retrait d'un client
	 * @param int cid identifiant client
	 */
	removeClient: function(c) {
		var i = this._aClients.indexOf(c);
		if (i >= 0) {
			this._aClients.splice(i, 1);
			c.setInstance(null);
			this.buildSockets();
		} else {
			throw new Error('client #' + c.getId() + ' not in game');
		}
	},
	
	/**
	 * Renvoie le client associé à l'ID
	 * @return Client
	 */
	getClient: function(cid) {
		return this._aClients[cid];
	},
	
	/**
	 * Renvoie la totalité des clients connecté à l'instance
	 * @return array of Client
	 */
	getClients: function() {
		return this._aClients;
	},
	
	getEntities: function() {
		return this._oHorde.aHorde;
	},
	
	/**
	 * Renvoie la liste des entités controllées par des clients
	 */
	getClientEntities: function() {
		return this._aClientEntities;
	},
	
	
	getHorde: function() {
		return this._oHorde;
	},

	/**
	 * Renvoie la liste des entités qui sont comprise dans la forme spécifée
	 * @returns
	 */
	getAreaEntities: function(aTypes, xCenter, yCenter, nRadius) {
		var aPeople = [];
		var x, y;
		var nRadiusBlock = (nRadius >> 6) + 1;
		var nSize = this.getMapSize();
		var xSector = xCenter >> 6;
		var ySector = yCenter >> 6;
		for (y = ySector - nRadiusBlock; y < (ySector + nRadiusBlock); ++y) {
			if (y >= 0 && y < nSize) {
				for (x = xSector - nRadiusBlock; x < (xSector + nRadiusBlock); ++x) {
					if (x >= 0 && x < nSize) {
						aPeople = aPeople.concat(this.getMapBlockProp(x, y, 'entities'));
					}
				}
			}
		}
		nRadius *= nRadius;
		return aPeople.filter(function(p) {
			if (aTypes === null || aTypes.indexOf(p.getType()) >= 0) {
				var dx = p.x - xCenter;
				var dy = p.y - yCenter;
				return (dx * dx + dy * dy) <= nRadius;
			} else {
				return false;
			}
		}).sort(function(a, b) {
			var dx, dy, da, db;
			dx = a.x - xCenter;
			dy = a.y - yCenter;
			da = dx * dx + dy * dy;
			dx = b.x - xCenter;
			dy = b.y - yCenter;
			db = dx * dx + dy * dy;
			return da - db;
		});
	},
	
	
	/**
	 * Chargement de données de la partie
	 * @param string sFile fichier JSON contenant les données
	 * @returns
	 */
	loadData: function(sFile) {
		this._aOpenDoors = [];
		this._aOpenSecretDoors = [];
		this._oLevel = this._oMapper.load(sFile);
		// hum hum .map.map
		// heureusement que _oLevel n'est pas un array
		// le premier map est la propriété de oData (c'est un Array).
		// le second map est la fonction d'itération de cet Array
		this._aMapProp = this._oLevel.map.map(function(row, y) {
			return row.map(function (cell, x) {
				return {x: x, y: y, initial: cell, entities: []};
			});
		});
		this._oTags = {};
		
		// construction des tag et renseignement des map block
		var d = this._oLevel;
		var oThis = this;
		d.tags.forEach(function(oTag) {
			oThis.setMapBlockProp(oTag.x, oTag.y, 'tag', oTag.tag);
		});
		
		// construction des points de respawn
		this._oSpawnPoints = {};
		var t = {};
		
		/**
		 * Quelle est la plus longue distance N S E W
		 * depuis ce point x y ?
		 */
		var getLongestView = function(x, y) {
			var oViews = [
			    { // north
			    	a: 3,
			    	dx: 0,
			    	dy: -1,
			    	dist: 0
			    },
			    { // east
			    	a: 0,
			    	dx: 1,
			    	dy: 0,
			    	dist: 0
			    },
			    { // south
			    	a: 1,
			    	dx: 0,
			    	dy: 1,
			    	dist: 0
			    },
			    { // west
			    	a: 2,
			    	dx: -1,
			    	dy: 0,
			    	dist: 0
			    }
			];
			oViews.forEach(function(v) {
				var bx = x;
				var by = y;
				while (oThis.getMapBlockPhys(bx, by) == CONST.BLOCK_VOID) {
					bx += v.dx;
					by += v.dy;
					++v.dist;
				}
			});
			oViews.sort(function(a, b) {
				return b.dist - a.dist; 
			});
			return oViews[0].a * Math.PI / 2;
		};
		
		d.tags.forEach(function(oTag) {
			var aTag = oTag.tag.split(' ');
			if (aTag[0] == 'spawn') {
				var sSPType = aTag[1]; 
				if (!(sSPType in t)) {
					t[sSPType] = [];
				}
				t[sSPType].push({
					x: oTag.x,
					y: oTag.y,
					a: getLongestView(oTag.x, oTag.y)
				});
			}
		}, this);
		this._oSpawnPoints = t;
	},

	
	/**
	 * L'instance s'aquitte de ses tache périodique
	 * - Calcul des position des mobiles
	 * - Vérification des porrte et refermeture automatique
	 */
	
	process: function(bGetState) {
		var aStates = null;
		var aSouls = null;
		var oSoul;
		var oSoulChanges;
		var aDestroy = null;
		
		this._bStating = bGetState;
		++this._nTimeMod;
		
		if ((this._nTimeMod % 25) === 0) {
			// toutes les secondes
			++this._nTime;
			this._oEffectProcessor.processEffects();
			this.sendSignal('timeSecond', {t: this.getTime()});
		}
		
		if (bGetState) {
			aStates = [];
		}
		this._oHorde.each(function(e) {
			if (e.isActive()) { // que les entités actives
				e.process(); // l'entité vit sa vie
				oSoul = e.getSoul();
				if (oSoul) {
					oSoulChanges = oSoul.getData('changes');
					if (oSoulChanges) {
						// il y a des changements
						if (!aSouls) {
							aSouls = [];
						}
						oSoulChanges.i = e.getId(); // on ajoute l'id de l'entité
						aSouls.push(oSoulChanges); // hop dans la liste
						oSoul.setData('changes', null);
					}
				}
				if (bGetState) { // c'est l'heure des comptes ? 
					if (e.isStateChanged()) { // l'état physique de l'entité change ?
						aStates.push(e.getState()); // on va l'envoyer
					}
				}
				if (!e.isActive()) { // l'entité n'est plus active ?
					if (!aDestroy) { 
						aDestroy = []; // creation de la liste des morts
					}
					aDestroy.push(e); // elle a clamsé : on la pysh dans la liste
				}
			} else { // l'entité n'était pas active
				if (!aDestroy) {
					aDestroy = []; // creation de la liste des morts
				}
				aDestroy.push(e); // on la push dans la liste 
			}
		});
		if (aDestroy) { // y'a une liste des morts ?
			// on detruit toutes les entité de la liste
			var nDestroyCount = aDestroy.length;
			for (var iEnt = 0; iEnt < nDestroyCount; ++iEnt) {
				this.destroyEntity(aDestroy[iEnt]);
			}
		}
		// verifions l'état des portes auto refermante
		this.checkOpenDoors();
		var r = null;
		if (aStates || aSouls) {
			r = {};
			if (aStates) {
				r.states = aStates;
			}
			if (aSouls) {
				r.souls = aSouls;
			}
		}
		var aNM = this.popNetworkMessage();
		while (aNM) {
			this.doNetworkMessage(aNM);
			aNM = this.popNetworkMessage();
		}
		return r;
	},
	
	getStatus: function() {
		var oStatus = {};
		oStatus.id = this._id;
		oStatus.name = this._sName;
		oStatus.clients = this._aClients.map(function(c) { return c.getName(); });
		oStatus.entities = this._oHorde.getStatus();
		return oStatus;
	},
	
	
	////// ENTITIES SECTION ////// ENTITIES SECTION ////// ENTITIES SECTION ////// ENTITIES SECTION //////
	////// ENTITIES SECTION ////// ENTITIES SECTION ////// ENTITIES SECTION ////// ENTITIES SECTION //////
	////// ENTITIES SECTION ////// ENTITIES SECTION ////// ENTITIES SECTION ////// ENTITIES SECTION //////

	/**
	 * Ajoute une nouvelle entité à la horde
	 */
	spawnEntity: function(sBlueprint, x, y, a) {
		var oEntity = new Entity();
		if (sBlueprint) {
			if (!(sBlueprint in BLUEPRINTS)) {
				throw new Error('unknown blueprint : ' + sBlueprint);
			}
			oEntity.sBlueprint = sBlueprint;
			var oBP = oEntity.oBlueprint = BLUEPRINTS[sBlueprint];
			if (oBP.thinker) {
				var T = require('./Thinkers/' + oBP.thinker + 'Thinker.js');
				var oThinker = new T();
				oThinker.oGame = this;
				oEntity.setThinker(oThinker);
			}
			oEntity.nSize = oBP.width >> 1;
			oEntity.onEnterSector = this.boundEntityEnteringSector;
			oEntity.move(x, y);
			oEntity.setViewAngle(a);
			oEntity.setCreationTime(this.getTime());
			oEntity.onLeaveSector = this.boundEntityLeavingSector;
			var nType = oEntity.getType();
			switch (nType) {
				case CONST.ENTITY_TYPE_MISSILE:
					oEntity.setSpeedVector(a, oBP.speed);
					break;

				default:
					oEntity.setSpeedVector(a, 0);
					break;
			}
		}
		this._oHorde.recruit(oEntity);
		this.sendSignal('entitySpawned', {e: oEntity});
		return oEntity;
	},

	/**
	 * Supprime l'entité spécifiée
	 * @param eid identifiant de l'entité | ou entité elle même
	 */
	destroyEntity: function(oEntity) {
		// detruire les effets liés à l'entité
		this._oEffectProcessor.removeEffectsOfDeadEntity(oEntity);
		this.unregisterEntity(oEntity);
		this.doDestroyEntity(oEntity);
		this._oHorde.dismiss(oEntity);
	},
	
	/**
	 * Renvoie l'entité dont l'identifiant est spécifié
	 * @param int i identifiant
	 * @return Entity
	 */
	getEntity: function(i) {
		return this._oHorde.get(i);
	},
	
	/**
	 * Creation d'une entité pour le client
	 * Et positionnement sur un spawn point
	 * @param Client oClient client concerné
	 * @param string sBlueprint type d'entité
	 * @param string sSpawnPoint type de spanw point
	 * @returns oEntity
	 */
	createClientEntity: function(oClient, sBlueprint, sSpawnPoint) {
		var sp = this.getRandomSpawnPoint(sSpawnPoint);
		var xy = this.getNearestSafeSector(sp.x, sp.y);
		var ps = this._nPlaneSpacing;
		var ps2 = ps >> 1;
		var oEntity = this.spawnEntity(sBlueprint, xy.x * ps + ps2, xy.y * ps + ps2, sp.a, 0);
		oClient.setEntity(oEntity);
		oEntity.setData('idClient', oClient.getId());
		oEntity.setData('name', oClient.getName());
		oEntity.setData('creationTime', this._nTime);

		var oSoul = new Soul();
		oSoul.setData('idEntity', oEntity.getId());
		if (oEntity.oBlueprint.attributes) {
			for (var sAttr in oEntity.oBlueprint.attributes) {
				oSoul.setAttribute(sAttr, oEntity.oBlueprint.attributes[sAttr] | 0);
			}
		}
		oSoul.setOnAttributeChanged(this.soulAttributeChanged.bind(this));

		var oAttributes = oEntity.getData('attributes');
		oEntity.setData('soul', oSoul);
		for (var sAttr in oAttributes) {
			oSoul.setAttribute(sAttr, oAttributes[sAttr]);
		}
		oSoul.setAttribute('damage', 0);
		oSoul.setAttribute('vitality', 100);

		oEntity.setData('weapon', Items.create(oEntity.oBlueprint.weapon));
		this.buildClientEntities();
		this.sendSignal('playerIn', {c: oClient, e: oEntity});
	},

	/**
	 * Creation d'une entité monstre (non player character)
	 */
	createMonsterEntity: function(sBlueprint, x, y, a) {
		var xy = this.getNearestSafeSector(x, y);
		var ps = this._nPlaneSpacing;
		var ps2 = ps >> 1;
		var oEntity = this.spawnEntity(sBlueprint, xy.x * ps + ps2, xy.y * ps + ps2, a, 0);

		var oSoul = new Soul();
		oSoul.setData('idEntity', oEntity.getId());
		if (oEntity.oBlueprint.attributes) {
			for (var sAttr in oEntity.oBlueprint.attributes) {
				oSoul.setAttribute(sAttr, oEntity.oBlueprint.attributes[sAttr] | 0);
			}
		}
		oSoul.setOnAttributeChanged(this.boundSoulAttributeChanged);

		var oAttributes = oEntity.getData('attributes');
		oEntity.setData('soul', oSoul);
		for (var sAttr in oAttributes) {
			oSoul.setAttribute(sAttr, oAttributes[sAttr]);
		}
		oSoul.setAttribute('damage', 0);

		oEntity.setData('weapon', Items.create(oEntity.oBlueprint.weapon));
		oEntity.setData('name', oEntity.oBlueprint.name);
		this.doSpawnEntity(oEntity);
		return oEntity;
	},

	/**
	 * Détruit l'entité associée au client
	 * @param Client oClient
	 */
	destroyClientEntity: function(oClient) {
		var oEntity = oClient.getEntity();
		this._oEffectProcessor.stripEffects(oEntity, true);
		this.sendSignal('playerOut', {c: oClient, e: oEntity});
		this.unregisterEntity(oEntity);
		oEntity.setData('soul', null);
		oEntity.bActive = false;
		oClient.setEntity(null);
		this.buildClientEntities();
	},

	
	/**
	 * Une entité a été desouddée
	 * mais elle risque de revenir dans le jeu donc son instance ne doit pas 
	 * etre detruite.
	 * Détache une entité du jeu le temps de la remettre ailleur
	 * @param oEntity
	 */
	killEntity: function(oEntity) {
		this.unregisterEntity(oEntity);
		oEntity.bEthereal = true;
		this.doKillEntity(oEntity, oEntity.getData('aggressor'));
	},
	 
	 /**
	  * Faire réaparaitre une entité précédemment tuée
	  * @param Entity oEntity
	  */
	respawnEntity: function(oEntity, sSpawnPoint) {
		this.applyEffect(new Effect.Revive(), oEntity, oEntity);
		var sp = this.getRandomSpawnPoint(sSpawnPoint);
		var xy = this.getNearestSafeSector(sp.x, sp.y);
		var ps = this._nPlaneSpacing;
		var ps2 = ps >> 1;
		var x = xy.x * ps + ps2, y = xy.y * ps + ps2, a = sp.a;
		oEntity.bEthereal = false;
		oEntity.move(x, y);
		oEntity.setViewAngle(a);
		oEntity.setSpeedVector(a, 0);
		this.registerEntity(oEntity);
		this.doRespawnEntity(oEntity);
	 },
		 
	
	/**
	 * Une entité rentre dans un secteur 
	 * @param oEntity l'entité en question
	 * @param x ...
	 * @param y coordonnée du secteur
	 */
	entityEnteringSector : function(oEntity, x, y) {
		this.registerEntity(oEntity);
	},

	/**
	 * Une entité quitte un secteur
	 * @param oEntity l'entité en question
	 * @param x ...
	 * @param y coordonnée du secteur
	 */
	entityLeavingSector : function(oEntity, x, y) {
		this.unregisterEntity(oEntity);
	},

	/** 
	 * enregistre une entité dans l'un des secteur du Land
	 * @param oEntity
	 */
	registerEntity: function(oEntity) {
		var x = oEntity.xSector;
		var y = oEntity.ySector;
		var n = this.getMapSize();
		if (x >= 0 && y >= 0 && x < n && y < n) {
			var aRegister = this.getMapBlockProp(x, y, 'entities');
			if (aRegister.indexOf(oEntity) < 0) {
				aRegister.push(oEntity);
			}
		}
	},
	
	/**
	 * Désenregistre une entité de son secteur
	 */
	unregisterEntity: function(oEntity) {
		var x = oEntity.xSector;
		var y = oEntity.ySector;
		var n = this.getMapSize();
		if (x >= 0 && y >= 0 && x < n && y < n) {
			var aRegister = this.getMapBlockProp(x, y, 'entities');
			var nIndex = aRegister.indexOf(oEntity);
			if (nIndex >= 0) {
				aRegister.splice(nIndex, 1);
			}
		}
	},
	
	/**
	 * Renvoie le nombre de points de vie dont l'entité dispose actuellement
	 * @param Entity oEntity
	 * @return int
	 */
	getEntityHealth: function(oEntity) {
		var oSoul = oEntity.getSoul();
		var nHPMax = oSoul.getAttribute('vitality');
		return Math.min(nHPMax, Math.max(0, nHPMax - oSoul.getAttribute('damage')));
	},
	
	/**
	 * Invoquée lorsqu'un attribut change de valeur
	 * @param Soul oSoul soul dont l'attribut change
	 * @param string sAttribute nom de l'attribut qui a changé
	 * @param int nNewValue nouvelle valeur
	 * @param int nPreviousValue précédente valeur 
	 */
	soulAttributeChanged: function(oSoul, sAttribute, nNewValue, nPreviousValue) {
		var oSC = oSoul.getData('changes');
		var oEntity = this.getEntity(oSoul.getData('idEntity'));
		if (!oSC) {
			oSC = {}; 
			oSoul.setData('changes', oSC);
		}
		this.sendSignal('entityAttributeChanged', {e: oEntity, a: sAttribute, v: nNewValue, p: nPreviousValue});
		switch (sAttribute) {				
			case 'damage': // indiquer au client concerné une modif de sa barre de vie
				oSC.hp = this.getEntityHealth(oEntity);
				oSC.dhp = 100 * (nPreviousValue - nNewValue) / oSoul.getAttribute('vitality') | 0;
				this.sendSignal('entityDamaged', {e: oEntity, a: oEntity.getData('aggressor'), d: nNewValue - nPreviousValue});
				break;
				
			case 'dead':
				if (nNewValue > 0) {
					// Déclenche l'evenement killEntity
					// ne fonctionne que pour les entité qui on une Soul
					this.killEntity(oEntity);
				}
				break;	
			
			default:
				// les attributs de status
				// penser a mettre a jour aussi la fonction getSoulSnapshot si
				// on ajoute de nouveaux status
				oSC[sAttribute] = nNewValue;
				break;
		}
	},
	
	
	
	/**
	 * Snapshot complet de tous les Soul de toutes les creature
	 * Afin de renseigner les nouveau client arrivant
	 */
	getSoulSnapshot: function() {
		var a = [];
		var oInst = this;
		this._oHorde.each(function(e) {
			var oSoul = e.getSoul();
			if (oSoul) {
				var oRtn = {
					i: e.getId(),
					hp: oInst.getEntityHealth(e)
				};
				for (var sAttr in ATTR) {
					oRtn[sAttr] = oSoul.getAttribute(sAttr);
				}
				a.push(oRtn);
			}
		});
		return a;
	},
	
	createActionContext: function(sAction, oCaster) {
		return {
			instance: this,
			time: Date.now(),
			caster: oCaster,
			action: sAction,
			missiles: null,
			effects: null,
			fail: false,
			consume: false
		};
	},
	
	/**
	 * Applique un effet à une cible
	 * @param Effect oEffect effet
	 * @param Entity oTarget cible de l'effet
	 * @param Entity oSource source de l'effet
	 */
	applyEffect: function(oEffects, oTarget, oSource) {
		var ep = this._oEffectProcessor;
		if (Array.isArray(oEffects)) {
			oEffects.forEach(function(e) {
				this.applyEffect(e, oTarget, oSource);
			}, this);
		} else {
			oEffects.setTarget(oTarget);
			oEffects.setSource(oSource);
			this.sendSignal('effectApplied', {e: oEffects});
			ep.applyEffect(oEffects);
		}
	},
	
	
	/**
	 * Interprete les conséquence induite par l'utilisation d'un objet dans le contexte d'une action.
	 * @param object oContext
	 */
	postProcessContext: function(oContext) {
		// effets à appliquer au caster
		if (oContext.effects) {
			this.applyEffect(oContext.effects, oContext.caster, oContext.caster);
		}
		// missiles à lancer
		if (oContext.missiles) {
			var oInst = this;
			var e = oContext.caster;
			var o = {e: e};			
			oContext.missiles.forEach(function(m) {
				o.m = m;
				oInst.sendSignal('entityShot', {e: e, m: m});
			});
			this.doLaunchMissiles(oContext.missiles);
		}
	},
	

	
	////// MISSILE SECTION ////// MISSILE SECTION ////// MISSILE SECTION //////
	////// MISSILE SECTION ////// MISSILE SECTION ////// MISSILE SECTION //////
	////// MISSILE SECTION ////// MISSILE SECTION ////// MISSILE SECTION //////

	/**
	 * L'entité déclecnhe son attaque principale
	 * il s'agit de l'attaque emanant de l'arme équippée
	 */
	entityAttack: function(oEntity, nChargeTime) {
		var oWeapon = oEntity.getData('weapon');
		if (oWeapon) {
			var oContext = this.createActionContext('fire', oEntity);
			oContext.charge = nChargeTime;
			oWeapon.action(oContext);
			this.postProcessContext(oContext);
		} else {
			return null;
		}
	},
	
	/**
	 * L'entité déclenche l'utilisation de l'objet actuellement tenu en main
	 * L'objet produira des effet qui seront appliqué en retour a celui qui 
	 * l'utilise.
	 */
	entityUseItem: function(oEntity, nItem, bDontConsume) {
		this.sendSignal('entityUseItem', {e: oEntity, i: nItem, n: !!bDontConsume});
	},
	
	entityDropItem: function(oEntity, nItem) {
		this.sendSignal('entityDropItem', {e: oEntity, i: nItem});
	},
	
	
	/**
	 * Une entité tire un missile
	 * @param oShooter entité qui tire
	 * @param sBlueprint 
	 */
	shootMissile: function(oShooter, sBlueprint, fAngleDev) {
		var x = oShooter.x; 
		var y = oShooter.y;
		var d = oShooter.oBlueprint.width >> 1;
		var fAngle = oShooter.a + fAngleDev;
		x += d * Math.cos(fAngle);
		y += d * Math.sin(fAngle);
		var oMissile = this.spawnEntity(sBlueprint, x, y, fAngle);
		var oThinker = oMissile.oThinker;
		oThinker.setOwner(oShooter);
		oMissile.bSlideWall = false;
		oMissile.bInstable = true;
		oMissile.bEthereal = false;
		oMissile.setSpeedVector(fAngle, oMissile.oBlueprint.speed);
		return oMissile;
	},

	/**
	 * Fonction invoquée lorsqu'un missile percute un mobile
	 * @param Entity oMissile missile percutant
	 * @param Entity oTarget Cible percutée
	 */
	missileHitsTarget: function(oMissile, oTarget) {
		oMissile.bActive = false;
		if (oTarget) {
			var oPacket = {e: oTarget, m: oMissile, o: oMissile.getThinker().getOwner(), f: false};
			this.sendSignal('entityHit', oPacket);
			if (oPacket.f) {
			// pas d'application d'effet si l'un des mod l'en empeche
			// en mettan le flag f à true
				return;
			}
			var oShooter = oMissile.oThinker.getOwner();
			var aEffects = oMissile.getData('effects');
			this.applyEffect(aEffects, oTarget, oShooter);
		} else {
			// explosion contre un mur
			this.sendSignal('missileBump', {m: oMissile, o: oMissile.getThinker().getOwner()});
		}
	},

	doDestroyEntity: function(oEntity) {
		if (this.onDestroyEntity) {
			this.onDestroyEntity(this, oEntity);
		}
	},
	
	doLaunchMissiles: function(aMissiles) {
		if (this.onLaunchMissiles) {
			this.onLaunchMissiles(this, aMissiles);
		}
	},
	
	doNetworkMessage: function(aMessage) {
		if (this.onNetworkMessage) {
			this.onNetworkMessage(this, aMessage);
		}
	},

	
	doKillEntity: function(oEntity, oKiller) {
		this.sendSignal('entityDeath', {e: oEntity, k: oKiller});
		if (this.onEntityKilled) {
			this.onEntityKilled(this, oEntity, oKiller);
		}
		if (oEntity.getType() == CONST.ENTITY_TYPE_MOB) {
			oEntity.bActive = false;
		}
	}, 
	
	doSpawnEntity: function(oEntity) {
		if (this.onEntitySpawn) {
			this.onEntitySpawn(this, oEntity);
		}
	},
	
	doRespawnEntity: function(oEntity) {
		if (this.onEntityRespawn) {
			this.onEntityRespawn(this, oEntity);
		}
	},
	
	
	doEnd: function() {
		this.logMessage('terminating...');
		if (this.onEnd) {
			this.onEnd(this);
		}
		this.sendSignal('instanceTerminated');
	},
	

	sendSignal: function(sSignal, oParams) {
		if (this.onSignal) {
			this.onSignal(sSignal, this, oParams);
		}
	},
	
	////// MAP SECTION ////// MAP SECTION ////// MAP SECTION ////// MAP SECTION //////
	////// MAP SECTION ////// MAP SECTION ////// MAP SECTION ////// MAP SECTION //////
	////// MAP SECTION ////// MAP SECTION ////// MAP SECTION ////// MAP SECTION //////
	
	/**
	 * Tout pour gérer la map !!!
	 */
	
	/**
	 * Renvoie la taille de la map
	 * @return int
	 */
	getMapSize: function() {
		return this._oLevel.map.length;
	},
	
	/**
	 * Renvoie le code physique du block de la map actuellement chargée
	 * @param int x
	 * @param int y
	 * @return int
	 */
	getMapBlock: function(x, y) {
		return this._oLevel.map[y][x];
	},
	
	getMapBlockPhys: function(x, y) {
		return (this._oLevel.map[y][x] >> 12) & 0xF; // **code12** phys
	},
	
	getMapBlockCode: function(x, y) {
		return this._oLevel.map[y][x] & 0xFFF; // **code12** code
	},
	
	/**
	 * Modification d'un code du land avec transmission à tous les clients connectés
	 * @param x
	 * @param y position du block
	 * @param b nouvelle valeur du block
	 * @param sTag lorsque ce paramètre est renseigné cela signifie que la modification entre dans le cadre
	 * d'un mécanisme, il convient d'en informer les client (exemple: lors de l'ouverture d'un coffre)
	 */
	setMapBlock: function(x, y, b, sTag) {
		this._oLevel.map[y][x] = b;
		if (sTag && this.onMapChange) {
			this.onMapChange(this, x, y, b, sTag);
		}
	},
	
	setMapBlockPhys: function(x, y, b, sTag) {
		this.setMapBlock(x, y, (this._oLevel.map[y][x] & 0xFFFF0FFF) | (b << 12), sTag); // **code12** phys
	},
	
	setMapBlockCode: function(x, y, b, sTag) {
		this.setMapBlock(x, y, (this._oLevel.map[y][x] & 0xFFFFF000) | b, sTag); // **code12** code
	},
	
	/**
	 * Permet de définir les propriétés d'un block
	 * @param x ...
	 * @param y coordonnees du block
	 * @param sProp propriété
	 * @param sVal valeur de la prorpiété
	 */
	setMapBlockProp: function(x, y, sProp, sVal) {
		this._aMapProp[y][x][sProp] = sVal;
	},

	/**
	 * lecture des propriétés d'un block
	 * @param x ...
	 * @param y coordonnees du block
	 * @param sProp propriété
	 * @return valeur de la prorpiété
	 */
	getMapBlockProp: function(x, y, sProp) {
		try {
			return this._aMapProp[y][x][sProp];
		} catch (e) {
			throw new Error('out of range while reading grid at : ' + x.toString() + ':' + y.toString() + ' ' + typeof x + ' ' + typeof y);
		}
	},
	
	
	/**
	 * Retourne la walkabilité du block à partir de coordonnée pixel
	 * @param x ...
	 * @param y coordonnée pixel
	 * @return bool
	 */
	clip: function(x, y) {
		return !this.isWalkable(x >> 6, y >> 6);
	},
	

	/**
	 * une cellule est walkable si son code est inférieur à 16
	 * @param x ...
	 * @param y coordonnée de la cellule
	 * @return bool
	 */
	isWalkable: function(x, y) {
		return this.getMapBlockPhys(x, y) === 0;
	},	
	

	/**
	 * Renvoie les donnée de la partie de manière à les transmaettre au client
	 * @return object
	 */
	getData: function() {
		var oThis = this;
		var encodeDoor = function(d) {
			var x = d[0];
			var y = d[1];
			var oDD = [x, y];
			if (d.length > 4) {
				oDD.push(d[4]);
			} else {
				oDD.push(oThis.getMapBlock(x, y));
			}
			return oDD;
		};
		var aDoorData = this._aOpenDoors.map(encodeDoor)
			.concat(this._aOpenSecretDoors.map(encodeDoor));
		var oMapData = {m: this._oLevel, d: aDoorData};
		return oMapData;
	},
	
	/**
	 * Renvoie la position d'un point de respawn aléatoire
	 * @param string sType type de spawnpoint tel qu'il est déclaré dans le tag spawn de la carte
	 */
	getRandomSpawnPoint: function(sType) {
		if (sType in this._oSpawnPoints) {
			var sp = this._oSpawnPoints[sType];
			return sp[u.rand(0, sp.length - 1)];
		} else {
			throw new Error('no spawn point of type "' + sType + '" defined');
		}
	},


    /**
     * Effectue la téléportation d'une entité.
     * La téléportation s'effectue sur une case aléatoire autour de l'entité dans un rayons spécifié
     * @param oEntity Teleporting entity
     * @param yWarp position of teleport exit
     * @param xWarp
     */
	teleportEntity: function(oEntity, xWarp, yWarp) {
		if (!this.isWalkable(xWarp, yWarp)) {
			return false;
		}
		this.unregisterEntity(oEntity);
		var xPrev = oEntity.x;
		var yPrev = oEntity.y;
		var xy = this.getNearestSafeSector(xWarp, yWarp);
		if (xy) {
			var ps = this._nPlaneSpacing;
			var ps2 = ps >> 1;
			oEntity.move(xy.x * ps + ps2, xy.y * ps + ps2);
			this.registerEntity(oEntity);
			var xWarp64 = oEntity.x;
			var yWarp64 = oEntity.y;
			this.pushNetworkMessage(this.getClientEntities(), {m: 'vfx', b: 'o_teleport', x: xPrev, y: yPrev});
			this.pushNetworkMessage(this.getClientEntities(), {m: 'pos', i: oEntity.getId(), x: xWarp64, y: yWarp64});
			this.pushNetworkMessage(this.getClientEntities(), {m: 'vfx', b: 'o_teleport', x: xWarp64, y: yWarp64});
			this.logMessage('teleporting', oEntity.getData('name'), 'at', xWarp, yWarp);
			return true;
		} else {
			return false;
		}
	},
	
	/**
	 * Téléporte l'entité spécifiée jusqu'au premier secteur vide
	 * (pas de mur, pas d'entité)
	 * à proximité du secteur spécifié
	 * Les coordonnées renvoyée sont en pixels...
	 */
	getNearestSafeSector: function(x, y) {
		var oInst = this;
		/**
		 * Verifie qu'un secteur est bien candidat au téléport
		 */
		var checkSector = function(sx, sy) {
			if (sx >= 0 && sy >= 0 && sx < oInst.getMapSize() && sy < oInst.getMapSize()) {
				var oSector = oInst.getMapBlockProp(sx, sy, 'entities');
				if (oSector.length) {
					return false;
				}
				if (oInst.getMapBlockPhys(sx, sy) != 0) {
					return false;
				}
			} else {
				return false;
			}
			return true;
		};
		var xy, x64, y64;
		for (var i = 0; i < 80; ++i) {
			xy = Snail.getSnailXY(i);
			if (checkSector(x + xy[0], y + xy[1])) {
				x64 = x + xy[0]; 
				y64 = y + xy[1];
				return {x: x64, y: y64};
			}
		}
		throw new Error('no safe point found at ' + x.toString() + ' : ' + y.toString());
	},
	
	
	/**
	 * Ouverture d'une porte
	 * @param x position x de la porte
	 * @param y position y de la porte
	 * @return bool renvoie true si la porte à été ouverte ; et false si le block spécifié est une porte déja ouverte
	 */
	openDoor : function(x, y) {
		var nLimit = 0;
		switch (this.getMapBlockPhys(x, y)) {
			case CONST.BLOCK_DOOR_DOUBLE:
				nLimit = 32 * 1000 / 60 | 0;
				break;
	
			case CONST.BLOCK_DOOR_LEFT:
			case CONST.BLOCK_DOOR_RIGHT:
				nLimit = 64 * 1000 / 120 | 0;
				break;
	
			case CONST.BLOCK_DOOR_UP:
			case CONST.BLOCK_DOOR_DOWN:
			case CONST.BLOCK_CURTAIN_UP:
			case CONST.BLOCK_CURTAIN_DOWN:
				nLimit = 96 * 1000 / 120 | 0;
				break;
		}
		if (!nLimit) {
			// ce n'était pas une porte finalement.
			return false;
		}
		if (this.getMapBlockProp(x, y, 'dooropen')) {
			// aucun effet si la porte est déja ouverte
			return false;
		}
		this.setMapBlockProp(x, y, 'dooropen', true);
		var nNow = Date.now();
		this._aOpenDoors.push([x, y, nNow + CONST.DOOR_AUTOCLOSE_DELAY, nNow + nLimit]);
		return true;
	},

	/**
	 * L'ouverture d'une porte secrete. L'ouverture s'effectue, puis au bout du
	 * temps écoulé le block devient vide puis c'est au tour du bloc suivant
	 * @param x position x de la porte
	 * @param y position y de la porte
	 * @return bool renvoie true si la porte à été ouverte ; et false si le block spécifié est une porte déja ouverte
	 */
	openSecretDoor : function(x, y) {
		var bDoorOpen = this.getMapBlockProp(x, y, 'dooropen');
		if (bDoorOpen) {
			// aucun effet si la porte est déja ouverte
			return false;
		}
		this.setMapBlockProp(x, y, 'dooropen', true);
		var nLimit = 64 * 1000 / 40 | 0;
		var nNow = Date.now();
		var bs = CONST.BLOCK_SECRET;
		var nCloseTime = nNow + CONST.SECRET_DOOR_AUTOCLOSE_DELAY - nLimit;
		var nCloseDuration = nNow + (nLimit << 1);

		this._aOpenSecretDoors.push([ x, y, nCloseTime, nCloseDuration ]);
		this.setMapBlockProp(x, y, 'tag', CONST.SECRET_ZONE_TAG);

		// vérifier les secteur adjacent
		if (this.getMapBlockPhys(x + 1, y) == bs) {
			this._aOpenSecretDoors.push([ x + 1, y, nCloseTime, nCloseDuration ]);
			this.setMapBlockProp(x + 1, y, 'tag', CONST.SECRET_ZONE_TAG);
			return true;
		}

		if (this.getMapBlockPhys(x - 1, y) == bs) {
			this._aOpenSecretDoors.push([ x - 1, y, nCloseTime, nCloseDuration ]);
			this.setMapBlockProp(x - 1, y, 'tag', CONST.SECRET_ZONE_TAG);
			return true;
		}

		if (this.getMapBlockPhys(x, y + 1) == bs) {
			this._aOpenSecretDoors.push([ x, y + 1, nCloseTime, nCloseDuration ]);
			this.setMapBlockProp(x, y + 1, 'tag', CONST.SECRET_ZONE_TAG);
			return true;
		}

		if (this.getMapBlockPhys(x, y - 1) == bs) {
			this._aOpenSecretDoors.push([ x, y - 1, nCloseTime, nCloseDuration ]);
			this.setMapBlockProp(x, y - 1, 'tag', CONST.SECRET_ZONE_TAG);
			return true;
		}
		return true;
	},
	
	/**
	 * Fermeture d'une porte
	 */
	closeDoor : function(x, y) {
		this.setMapBlockProp(x, y, 'dooropen', false);
		this.doCloseDoor(x, y);
	},
	
	/**
	 * Fermeture d'une porte secrete
	 */
	closeSecretDoor : function(x, y) {
		this.setMapBlockProp(x, y, 'dooropen', false);
		this.doCloseDoor(x, y);
	},
	
	/**
	 * Vérifie la présence d'entité dans les zones secretes
	 */
	checkSecretZoneEntityPresence : function() {
		var ix, iy, nSize = this.getMapSize();
		for (iy = 0; iy < nSize; ++iy) {
			for (ix = 0; ix < nSize; ++ix) {
				if (this.getMapBlockProp(ix, iy, 'tag') == CONST.SECRET_ZONE_TAG && this.getMapBlockProp(ix, iy, 'entities').length) {
					return true;
				}
			}
		}
		return false;
	},


	/**
	 * Verification generale des portes Pour chaque porte si son delai
	 * d'autoclose expire on verifie si on peut la fermer (personne entre les
	 * battants) puis on la ferme. si ca coince on augmente le délai
	 */
	checkOpenDoors : function() {
		var d, x, y, t, nBlock, nPhys;
		var nTime = Date.now();
		var od = this._aOpenDoors;
		var iDoor = od.length - 1;
		while (iDoor >= 0) {
			d = od[iDoor];
			t = d[2];
			x = d[0];
			y = d[1];
			nBlock = this.getMapBlock(x, y);
			nPhys = this.getMapBlockPhys(x, y);
			if (nPhys != CONST.BLOCK_VOID) {
				// si limit est a zero of marque la zone comme
				// traversable
				if (d[3] < nTime) {
					// virer la porte
					this.setMapBlockPhys(x, y, CONST.BLOCK_VOID);
					// sauver le précédent code du bloc pour le restituer à la fermeture
					d[4] = nBlock;
				}
			}

			if (t <= nTime) {
				x = d[0];
				y = d[1];
				if (this.getMapBlockProp(x, y, 'entities').length) {
					d[2] += CONST.DOOR_AUTOCLOSE_DELAY >> 1;
				} else {
					this.closeDoor(x, y);
					// remettre le code précédement sauvé à l'ouverture
					this.setMapBlock(x, y, d[4]);
					od.splice(iDoor, 1);
				}
			}
			--iDoor;
		}

		// secret doors
		od = this._aOpenSecretDoors;
		iDoor = od.length - 1;
		var nSZEP = 0;
		while (iDoor >= 0) {
			d = od[iDoor];
			t = d[2];
			x = d[0];
			y = d[1];
			nBlock = this.getMapBlock(x, y);
			nPhys = this.getMapBlockPhys(x, y);
			//bSecretCheck = this.getMapBlockProp(x, y, 'tag') == CONST.SECRET_ZONE_TAG; 
			if (nPhys != CONST.BLOCK_VOID) {
				// si limit est a zero of marque la zone comme
				// traversable
				if (d[3] < nTime) {
					this.setMapBlockPhys(x, y, CONST.BLOCK_VOID);
					d[4] = nBlock;
				}
			}

			if (t <= nTime) {
				x = d[0];
				y = d[1];
				// déterminer la liste des secteurs a verifier pour qu'aucun
				// joueur ne se retrouve coincé
				// dans le passage secret.
				if (nSZEP == 0) {
					nSZEP = this.checkSecretZoneEntityPresence() ? 1 : 2;
				}
				if (nSZEP == 2) { // personne
					this.setMapBlock(x, y, d[4]);
					this.closeSecretDoor(x, y);
					od.splice(iDoor, 1);
				} else {
					d[2] += CONST.SECRET_DOOR_AUTOCLOSE_DELAY >> 1;
				}
			}
			--iDoor;
		}
	},
	
	doOpenDoor: function(x, y) {
		if (this.onOpenDoor) {
			this.onOpenDoor(this, x, y);
		}
	},

	doCloseDoor: function(x, y) {
		if (this.onCloseDoor) {
			this.onCloseDoor(this, x, y);
		}
	},

	/**
	 * Une entity vient d'activer un mur
	 * 
	 * @param oEntity entité
	 * @param x
	 * @param y coordonnée du mur
	 */
	wallActivate : function(oEntity, x, y) {
		var nBlockCode = this.getMapBlockPhys(x, y);
		var sTag = this.getMapBlockProp(x, y, 'tag');
		if (sTag) {
			this.sendSignal('entityActivateWall', {e: oEntity, x: x, y: y, t: sTag});
		}
		switch (nBlockCode) {
			case CONST.BLOCK_DOOR_DOUBLE:
			case CONST.BLOCK_CURTAIN_UP:
			case CONST.BLOCK_CURTAIN_DOWN:
			case CONST.BLOCK_DOOR_UP:
			case CONST.BLOCK_DOOR_DOWN:
			case CONST.BLOCK_DOOR_LEFT:
			case CONST.BLOCK_DOOR_RIGHT:
				if (this.openDoor(x, y)) {
					this.doOpenDoor(x, y);
				}
				break;
	
			case CONST.BLOCK_SECRET:
				if (this.openSecretDoor(x, y)) {
					this.doOpenDoor(x, y);
				}
				break;
		}
	}
});

module.exports = Instance;
