var O2 = require('o2');
var Thinker = require('./MagicMissileThinker.js');
var u = require('mwgame/Utils.js');
var CONST = require('mwgame/data/consts.js');
//donnée ciollisionnelles
var xCollisions = [0, 1, 0, -1];	// Tableau des collision
var yCollisions = [-1, 0, 1, 0];	// ...


O2.extendClass('BouncingMissileThinker', MagicMissileThinker, {
	
	_nBounces : 0,
	
	computeWallCollision: function() {
		var oEntity = this.oEntity;
		var x = oEntity.x;
		var y = oEntity.y;
		var dx = oEntity.dx;
		var dy = oEntity.dy;

		var ix, iy;
		var bx = false;
		var by = false;
		
		// tester les secteurs

		var nSize = oEntity.getSize();
		var oGame = this.oGame;

		// calculer le cadran (point cardinal dominant dans lequel se déplace l'entity
		// permet d'eviter de se faire coincer le cul de chemise dans la porte qui se referme
		var nXYFormula = (Math.abs(dx) > Math.abs(dy) ? 1 : 0) | ((dx > dy) || (dx == dy && dx < 0) ? 2 : 0);

		for (var i = 0; i < 4; ++i) {
			if (nXYFormula == i) {
				continue;
			}
			ix = nSize * xCollisions[i] + x;
			iy = nSize * yCollisions[i] + y;
			if (oGame.clip(ix + dx, iy)) {
				bx = true;
				if (!oEntity.bSlideWall) {
					by = true;
				}
			}
			if (oGame.clip(ix, iy + dy)) {
				by = true;
				if (!oEntity.bSlideWall) {
					bx = true;
				}
			}
			if (bx && by) {
				var sm = -oEntity.fSpeedModifier;
				oEntity.move(dx * sm + x, dy * sm + y);
				break;
			}
		}
		if (bx || by) {
			this.bump(bx, by);
			dx = bx ? -dx : dx;
			dy = by ? -dy : dy;
			oEntity.setCourse(Math.atan2(dy, dx));
		}
	},
	
	bump: function(bx, by) {
		O2.parent(this, bx, by);
		++this._nBounces;
		if (this._nBounces > 20) {
			return;
		}
		this.oEntity.bActive = true;
	},

	
	resolveCollision : function(oTarget) {
		O2.parent(this, oTarget);
		var e = this.oEntity;
		e.bActive = true;
		e.setCourse(this.oEntity.a + Math.PI);
		var g = this.oGame;
		g.pushNetworkMessage(g.getClientEntities(), {m: 'vfx', b: 'o_bumporb', x: e.x, y: e.y});
	}
});

module.exports = BouncingMissileThinker;
