/**
 * Classe de construction d'un niveau à partir de données brutes issues d'un générateur
 * La classe accepte ...
 *  - un tableau à deux dimensions composé de codes logiques
 *  - une palette associant les codes logiques à des codes physiques
 *  - des références à des textures
 */

var fs = require('fs');
var BLOCK = require('./data/blocks.js');
var LEVELS = {};


function load(sMap) {
	if (sMap in LEVELS) {
		return LEVELS[sMap];
	}
	var l = LEVELS[sMap] = {};
	var oData = JSON.parse(fs.readFileSync(__dirname + '/data/maps/' + sMap));

	l.map = [];
	var m = oData.map;
	var c = oData.palette;
	
	var oWalls = [];
	var oFlats = [];
	// indexation des codes de la palette
	var i = 0;
	for (var pn in c.blocks) {
		c.blocks[pn].i = i; // ajout de l'indice
		oWalls[i] = c.blocks[pn].w; // enregistrement du mur
		oFlats[i] = c.blocks[pn].f; // enrigistrement sol/plafond
		++i;
	}
	var x = 0, y = 0, mxy, cmxy, v, n = oData.map.length;

	for (y = 0; y < n; ++y) {
		r = [];
		for (x = 0; x < n; ++x) {
			mxy = m[y][x] & 0xFF;
			// composer le code physique
			if (!(mxy in c.blocks)) {
				throw new Error('map does not contain this code : 0x' + mxy.toString(16));
			}
			cmxy = c.blocks[mxy];
			v = cmxy.i | (cmxy.c << 8) | (cmxy.o << 16);
			r.push(v);
		}
		l.map.push(r);
	}
	
	if ('uppermap' in oData) {
		m = oData.uppermap;
		l.uppermap = [];
		for (y = 0; y < n; ++y) {
			r = [];
			for (x = 0; x < n; ++x) {
				mxy = m[y][x] & 0xFF;
				// composer le code physique
				if (!(mxy in c.blocks)) {
					throw new Error('map does not contain this code : 0x' + mxy.toString(16));
				}
				cmxy = c.blocks[mxy];
				v = cmxy.i | (cmxy.c << 8) | (cmxy.o << 16);
				r.push(v);
			}
			l.uppermap.push(r);
		}
	}
	
	
	l.visual = oData.visual;
	l.walls = {
		src: 'resources/gfx/textures/' + c.walls + '.png',
		codes: oWalls
	};
	l.flats = {
		src: 'resources/gfx/textures/' + c.flats + '.png',
		codes: oFlats
	};
	l.background = 'resources/gfx/textures/' + c.background + '.png';
	l.tiles = {};
	l.blueprints = [];
	l.visual = oData.visual;
	l.startpoint = {
		x: oData.startpoint.x,
		y: oData.startpoint.y,
		angle: oData.startpoint.angle,
	};
	l.objects = oData.objects;
	l.tags = oData.tags;
	return l;
}

module.exports = {
	BLOCK: BLOCK,
	load: load
};
