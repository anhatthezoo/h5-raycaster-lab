/**
 * Permet d'interpreter les effets des objet utilisé
 */

var O2 = require('o2');
var mediator = require('mediator');
var Plugin = mediator.Plugin;
var Inventory = require('gc').Inventory;
var Items = require('mwgame/Items.js');
var u = require('mwgame/Utils.js');


O2.extendClass('ModEmporium', Plugin, {
	
	CONFUSION_MISUSE_CHANCE: 60,
	
	getName: function() {
		return 'ModEmporium';
	},
	
	/**
	 * Mise à jour de l'inventaire
	 * Serialisation et envoie à l'instance
	 */
	updateInventory: function(oInstance, oEntity) {
		this.sortInventory(oEntity);
		var oInv = oEntity.getData('inventory');
		// sérializer l'inventaire
		var aNew = oInv.aBagSlots.filter(this.filterNewItem);
		aNew.forEach(this.deleteNewFlag);
		var sInv = JSON.stringify({
			inv: oInv.aBagSlots.map(this.inventoryMap),
			newones: aNew.map(this.inventoryMap)
		});
		// envoi à l'instance
		oInstance.pushNetworkMessage([oEntity], {m: 'inv', i: sInv});
	},
	
	init: function() {
		this.register('entitySpawned');
		this.register('entityUseItem');
		this.register('entityPickUpItem');
		this.register('entityDropItem');
	},

	entitySpawned: function(oInstance, oData) {
		oEntity = oData.e;
		var oBP = oEntity.oBlueprint;
		if (oBP.inventory) {
			var i = new Inventory();
			i.setSize(oBP.inventory.size);
			oEntity.setData('inventory', i);
			this.entityPickUpItem(oInstance, {e: oEntity, i: oBP.inventory.items});
		}
	},

	newItem: function(sItem) {
		var oItem = Items.create(sItem);
		oItem.__new = true;
		return oItem;
	},
	
	
	entityDropItem: function(oInstance, oData) {
		var oEntity = oData.e;
		var oSoul = oEntity.getSoul();
		var bConfused = oSoul.getAttribute('confused') > 0;
		var nItem = oData.i;
		var oInv = oEntity.getData('inventory');
		var oItem = oInv.aBagSlots[nItem];
		/**
		 * Si on est confus, on prend au hasard un item dans l'inventaire
		 * sans tenir compte de celui qui a été choisi par le joueur
		 * si l'inventaire contient peu d'objet, on a de grande chance 
		 * de retomber sur l'item qu'on avait choisi
		 */
		if (bConfused) {
			nItem = u.rand(0, oInv.getSize() - 1);
			if (oInv.aBagSlots[nItem]) {
				oItem = oInv.aBagSlots[nItem];
			}
		}
		if (oItem) {
			oInv.removeItem(oItem, 1);
			oInstance.logMessage(oEntity.getData('name') + ' dropped ' + oItem.resref);
			this.updateInventory(oInstance, oEntity);
		}
	},
	
	/**
	 * The action of using an item can be disturbed by some specific effect. 
	 */
	filterActionEffect: function(oEntity, oItem) {
		var oSoul = oEntity.getSoul();
		var bConfused = oSoul.getAttribute('confused') > 0;
		var bBlind = oSoul.getAttribute('blind') > 0;
		var bDocument = oItem.type === 'scroll' || oItem.type === 'spellbook';
		var sAction = 'use';
		/**
		 * Si on est confus on misuse l'item
		 * Ce qui, pour les scrolls donne des choses pas tristes
		 */
		if (bConfused && bDocument) {
			sAction = u.prob(this.CONFUSION_MISUSE_CHANCE) ? 'misuse' : 'use';
		}
		/** 
		 * Si on est aveugle on peut pas lire les scroll
		 */
		if (bBlind && bDocument) {
			sAction = 'cantread';
		}
		return sAction;
	},
	
	
	/**
	 * L'entité déclenche l'utilisation d'un objet
	 * L'objet produira des effet qui seront appliqué en retour a celui qui 
	 * l'utilise.
	 * data : {
	 * 		e: entity
	 * 		i: num item
	 * 		n: don't consume the item event if potion or scroll
	 * }
	 */
	entityUseItem: function(oInstance, oData) {
		var oEntity = oData.e;
		var sAction;
		var nItem = oData.i;
		var oInv = oEntity.getData('inventory');
		var oItem = oInv.aBagSlots[nItem];
		if (oItem) {
			sAction = this.filterActionEffect(oEntity, oItem);
			switch (sAction) {
				case 'cantread':
					oInstance.pushNetworkMessage([oEntity], {
						m: 'msg', 
						s: 'alert_wtf_blindread_' + u.rand(0, 1), 
						i: 'wtf_blind'
					});
					sAction = null;
					break;
					
				case 'misuse':
					oInstance.pushNetworkMessage([oEntity], {
						m: 'msg', 
						s: 'alert_wtf_confusedread_' + u.rand(0, 1), 
						i: 'wtf_confused'
					});
					break;
			}
			if (sAction) {
				var oContext = oInstance.createActionContext(sAction, oEntity);
				oItem.action(oContext);
				if (oContext.consume && !oData.n) {
					oInv.removeItem(oItem, 1);
				} else 	if ('cooldown' in oContext) { // objet avec un cooldown
					oInstance.pushNetworkMessage([oEntity], {
						m: 'cooldown',
						n: oContext.cooldown,
						i: nItem
					});
				}
				oInstance.postProcessContext(oContext);
				this.updateInventory(oInstance, oEntity);
			}
		}
	},

	
	entityPickUpItem: function(oInstance, oData) {
		var oEntity = oData.e;
		var aItems = oData.i;
		var i = oEntity.getData('inventory');
		for (var iItem = 0; iItem < aItems.length; ++iItem) {
			sItem = aItems[iItem];
			if (i.isFull()) {
				oData.f = true;
				break;
			} else {
				i.addItem(this.newItem(sItem));
			}
		}
		if (oData.f) {
			oInstance.pushNetworkMessage([oEntity], {
				m: 'msg', 
				s: 'alert_wtf_invfull', 
				i: 'wtf_chest'
			});
		} else {
			this.updateInventory(oInstance, oEntity);
		}
	},

	inventoryMap: function(it) {
		if (it) {
			if (it.type === 'potion' && it.frozen) {
				return 'pot_frozen';
			} else {
				return it.resref;
			}
		} else {
			return null;
		}
	},
	
	sortInventory: function(oEntity) {
		var oInv = oEntity.getData('inventory');
		oInv.aBagSlots.sort(function(a, b) {
			if (!a) {
				return 1;
			}
			if (!b) {
				return -1;
			}
			var ax = a.type;
			var bx = b.type;
			if (ax == bx) {
				if (a.resref == b.resref) {
					return 0;
				} else {
					return a.resref < b.resref ? 1 : -1;
				}
			} else {
				return ax < bx ? 1 : -1;
			}
		});
	},
	
	filterNewItem: function(a) {
		if (a) {
			return !!a.__new;
		} else {
			return false;
		}
	},
	
	deleteNewFlag: function(a) {
		if (a) {
			delete a.__new;
		}
	}
});

module.exports = ModEmporium;
