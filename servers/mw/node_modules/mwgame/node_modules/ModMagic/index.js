/**
 * Un mod permettant de gérer quelques règles qui régissent la magie dans ce jeu
 */

var O2 = require('o2');
var mediator = require('mediator');
var Plugin = mediator.Plugin;
var Effect = require('mwgame/Effects.js');
var u = require('mwgame/Utils.js');


var ModMagic = O2.extendClass(Plugin, {
	getName: function() {
		return 'ModMagic';
	},
	
	init: function() {
		this.register('entityDamaged');
		this.register('entityShot');
		this.register('entityHit');
		this.register('entityDeath');
		this.register('effectApplied');
	},
	
	/**
	 * L'entité donne un peu de ses points de vie a son aggresseur
	 * @param oInstance
	 * @param oEntity entité qui a subit des dégâts
	 * @param oAgg aggresseur (entité qui a occasionné les dégats)
	 * @param nDamage dégât occasionné lors de l'impact du missile
	 */
	processVampyre: function(oInstance, oEntity, oAgg, nDamage) {
		if (!oAgg) {
			return;
		}
		if (oAgg == oEntity) {
			return;
		}
		if (!oAgg.getSoul()) {
			console.error('wtf ! no soul for this object : ', oAgg);
			return;
		}
		var nVampyre = oAgg.getSoul().getAttribute('vampyre');
		if (nVampyre > 0) {
			var nLife = Math.min(nDamage, Math.max(1, nDamage * (nVampyre / 100) | 0));
			oInstance.applyEffect(new Effect.Heal(nLife), oAgg, oEntity);
		}
	},
	
	/**
	 * Entité endommagée : on procede à la vérification et l'application du
	 * système de vampyre.
	 */
	entityDamaged: function(oInstance, oData) {
		var oEntity = oData.e;
		var oAggressor = oData.a;
		var nValue = oData.d;
		this.processVampyre(oInstance, oEntity, oAggressor, nValue);
	},
	
	/**
	 * Entité frappée par un missile : 
	 * - on diminue la force des effet "breakable"
	 * - on procede à l'application du reflect
	 */
	entityHit: function(oInstance, oData) {
		var oEntity = oData.e;
		var oMissile = oData.m;
		var oSoul = oEntity.getSoul();
		var oShooter = oMissile.getThinker().getOwner();
		var aEffs;
		// si l'entité est hold ou root on va reduire la durée de l'effet
		if (oSoul.getAttribute('hold') > 0 || oSoul.getAttribute('root') > 0) {
			// chercher un effet breakable
			aEffs = oSoul._aEffects.filter(function(oEff) {
				return oEff.hasTag('breakable');
			});
			if (aEffs.length > 0) {
				var oEff = aEffs[0];
				oEff.damage(1);
			}
		}

		// si l'entité est reflect on va appliquer les effets du missile
		// mais le missile sera renvoyé
		var nReflect = oSoul.getAttribute('reflect');
		if (nReflect > 0) {
			// l'entité a bien l'effet reflect et le missile qui la percute
			// n'a pas déja été réfléchi
			aEffs = oMissile.getData('effects');
			var aNewEffects = aEffs.map(function(e) { // copier les effets
				// Ces effets seront appliqué à la cible qui vient d'etre percuté
				// par le missile
				var s = e.getTag(0);
				var d = e.getDuration();
				var l = e.getLevel();
				if (e.hasTag('curse')) { // Mauvais effet : doit être traité par le shield
					if (e.getDurationType() === 1) { // effect temporaire : reduire la durée
						d = d * (1 - nReflect / 100) | 0;
					} else {
						l = l * (1 - nReflect / 100) | 0;
					}
				}
				var eNew = new Effect[s](l);
				eNew.setDuration(d);
				eNew.setSource(oShooter);
				return eNew;
			});
			if (!oMissile.getData('reflected')) {
				aEffs.forEach(function(e) { // reduction du niveau des effets avant reflection
					if (e.getDurationType() === 1) { // effect temporaire : reduire la durée
						e.setDuration(e.getDuration() * nReflect / 100 | 0);
					} else { // sinon reduire le niveau
						e.setLevel(e.getLevel() * nReflect / 100 | 0);
					}
					// ces effets seront renvoyé avec le missile
				});
				oMissile.bActive = true;
				oMissile.rollbackXY();
				oMissile.setCourse(oMissile.a + Math.PI);
				// ce missile sera "réfléchi" et ne pourra pas
				// être réfléchi à nouveau
				oMissile.setData('reflected', true);
			}
			oData.f = true; // annulation de l'application d'effet parente
			oInstance.applyEffect(aNewEffects, oEntity, oShooter);
		}
	},
	
	/**
	 * L'entité a tiré avec sa baguette
	 */
	entityShot: function(oInstance, oData) {
		var m = oData.m;
		var e = oData.e;
		var oSoul = e.getSoul();
		// si l'entité est confuse on nique la précision de tir
		if (oSoul.getAttribute('confused')) {
			m.setCourse(m.a + u.rand() / 2 - 0.25);
		}
		// si l'entité possède une augmentation de puissance de feu
		// on augmente les degâts des projectile
		var n = oSoul.getAttribute('power');
		if (n != 0) {
			m.getData('effects').forEach(function(oEffect) {
				if (oEffect.getDurationType == 1) {
					oEffect.setDuration(Math.max(1, oEffect.getDuration() * (1 + n / 100) | 0));  
				} else {
					oEffect.setLevel(oEffect.getLevel() * (1 + n / 100) | 0);
				}
			});
		}
		// si l'entité est invisible on supprime tous les effets invisibles
		if (oSoul.getAttribute('invisible') > 0) {
			oSoul._aEffects.forEach(function(oEffect) {
				if (oEffect.hasTag('Invisibility')) {
					oEffect.dispel();
				}
			});
			oInstance._oEffectProcessor.removeDeadEffects();
		}
	},
	
	entityDeath: function(oInstance, oData) {
		// flinguer les entités monstre invoquée
		var oEntity = oData.e;
		//var oKiller = oData.k;
		var oSummoner = oEntity.getData('summoner');
		var oSummoning = oEntity.getData('summoning');
		if (oSummoner) {
			// l'entité est un pet : virer le lien avec le maitre
			oSummoner.setData('summoning', null);
		}
		if (oSummoning) {
			// l'entité est un maitre : virer le lien avec le pet
			oEntity.setData('summoning', null);
			// et flinguer le pet
			oSummoning.getThinker().setThink('dead');
		}
	},
	
	effectApplied: function(oInstance, oData) {
		var oEffect = oData.e;
		var oTarget = oEffect.getTarget();
		var oSoul = oTarget.getSoul();
		var nDefense = oSoul.getAttribute('defense');
		if (nDefense) {
			if (oEffect.hasTag('curse')) {
				if (oEffect.getDurationType() === 1) { // effect temporaire : reduire la durée
					oEffect.setDuration(oEffect.getDuration() * (1 - nDefense / 100) | 0);
				} else { // sinon reduire le niveau
					oEffect.setLevel(oEffect.getLevel() * (1 - nDefense / 100) | 0);
				}
			}
		}
	}
});

module.exports = ModMagic;
