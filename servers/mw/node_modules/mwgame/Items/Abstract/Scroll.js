/**
 * Les parchemin de malédiction permettent de lancer une gerbe de 5 projectiles
 * infligeant des malédiction aux cibles touchées
 *
 * Les parchemin de protection permettent à celui qui les lits de bénéficier de protections
 * Ou d'autres effets utiles.
 */

var O2 = require('o2');
var Item = require('./Item.js');
var Effect = require('mwgame/Effects.js');

O2.extendClass('Scroll', Item, {
	type: 'scroll',
	missileRef: 'p_spell',
	missiles: 5,
	angle: 0.8,
	
	_aCursedEffects: null,
	_aBlessedEffects: null,
	
	curse: function(aEffects) {
		this._aCursedEffects = aEffects;
	},
	
	bless: function(aEffects) {
		this._aBlessedEffects = aEffects;
	},
	
	/**
	 * Génère une gerbe de missile chargé d'une malédiction.
	 * Chaque projectile se voit attribuér un ou plusieur effets.
	 * Le tableau en paramètre permet de spécifier les effet de chaque projectile
	 * Les éléments du tableau sont des effets instanciés.
	 * Certains élément peuvent etre des tableaux d'effets instancié auquel cas ils sont intégré dans le missile
	 * correspondant (ce missile vehiculera donc plusieur effets)
	 * @param aCurses Array of Effects | Array of Array of Effects
	 */
	makeCurse: function(ctx, aEffects) {
		var aCurses = [];
		var iCurse;
		var copyEffect = function(eSource) {
			var eCopy = new Effect[eSource.getTag(0)](eSource.getLevel());
			eCopy.setDuration(eSource.getDuration());
			return eCopy;
		};
		for (iCurse = 0; iCurse < this.missiles; ++iCurse) {
			if (Array.isArray(aEffects)) {
				aCurses.push(aEffects.map(function(myEff) { 
					return copyEffect(myEff); 
				}));
			} else {
				aCurses.push(copyEffect(aEffects));
			}
		}
		var oInst = ctx.instance;
		var aMissiles = [];
		var iMis;
		if (this.missiles > 1) {
			var fAngleBase = -this.angle / 2;
			var fAngleDiff = this.angle / (this.missiles - 1);
			for (iMis = 0; iMis < this.missiles; ++iMis) {
				aMissiles.push(oInst.shootMissile(ctx.caster, this.missileRef, iMis * fAngleDiff + fAngleBase));
			}
		} else {
			aMissiles.push(oInst.shootMissile(ctx.caster, this.missileRef, 0));
		}
		var m, c;
		for (iMis = 0; iMis < this.missiles; ++iMis) {
			m = aMissiles[iMis];
			c = aCurses[iMis];
			if (c) {
				if (Array.isArray(c)) {
					m.setData('effects', c);
				} else {
					m.setData('effects', [c]);
				}
			} else {
				m.setData('effects', []);
			}
		}
		ctx.missiles = aMissiles;
	},
	
	makeBless: function(ctx, aEffects) {
		if (Array.isArray(aEffects)) {
			ctx.effects = aEffects;
		} else {
			ctx.effects = [aEffects];
		}
	},
	
	
	use: function(ctx) {
		this.read(ctx);
		if (this._aCursedEffects) {
			this.makeCurse(ctx, this._aCursedEffects);
			this._aCursedEffects = null;
		}
		if (this._aBlessedEffects) {
			this.makeBless(ctx, this._aBlessedEffects);
			this._aBlessedEffects = null;
		}
		ctx.consume = true;
	},
	
	misuse: function(ctx) {
		this.read(ctx);
		if (this._aCursedEffects) {
			this.makeBless(ctx, this._aCursedEffects);
			this._aCursedEffects;
		}
		if (this._aBlessedEffects) {
			this.makeCurse(ctx, this._aBlessedEffects);
			this._aBlessedEffects = null;
		}
		ctx.consume = true;
	}
});

module.exports = Scroll;
