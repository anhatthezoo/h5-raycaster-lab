/**
 * Un thinker de base pour toute les créatures avec une IA
 */
var O2 = require('o2');
var MoverThinker = require('./MoverThinker.js');
var u = require('mwgame/Utils.js');
var Bresenham = require('mwgame/Bresenham.js');
var CONST = require('mwgame/data/consts.js');

O2.extendClass('CreatureThinker', MoverThinker, {
	
	_aActions: null,
	_nActionTime: 0,   // durée de l'action avant de passer à la suivante
	_sMode: 'idle', // think a appeler quand l'entité a terminé ses actions
	_oTarget: null,
	MAX_INVISIBLE_DISTANCE: 384,
	MAX_VISIBLE_DISTANCE: 640, 
	
	__construct: function() {
		O2.parent(this);
		this.setMode('wander');
	},
	
	setMode: function(s) {
		if (this._sMode != s) {
			this._sMode = s;
			this._aActions = [];
			this.setThink('idle');
		}
	},
	
	runAction: function() {
		if (this._nActionTime > 0) {
			--this._nActionTime;
		} else {
			var x = this._aActions.shift();
			if (x) {
				var sAction = x.shift();
				var sActionProc = 'action' + sAction.charAt(0).toUpperCase() + sAction.substr(1);
				this._nActionTime = x.shift();
				this[sActionProc].apply(this, x);
			} else {
				this.setThink('idle');
			}
		}
	},
	
	
	pushAction: function() {
		this._aActions.push(Array.prototype.slice.call(arguments, 0));
	},
	
	/**
	 * ne fais plus rien.
	 * en fonction du mode on redirige vers une nouvelle bordée de scripts
	 */
	thinkIdle: function() {
		this.runAction();
		switch (this._sMode) {
			case 'wander':
				this.pushAction('walk', 30, u.rand(0, 7) * Math.PI / 4);
				this.pushAction('stop', 60);
			break;
			
			case 'dead':
				this.pushAction('die');
			break;
		}
	},
	
	/**
	 * Déplce l'entité pendant un certain temps puis
	 * passe à l'action suivante
	 */
	thinkWalk: function() {
		this.runAction();
		this.thinkMove();
	},
	
	/**
	 * ne fais plus rien pendant un temps limité puis passe à l'action
	 * suivante
	 */
	thinkWait: function() {
		this.runAction();
	},
	
	thinkDead: function() {
		
	},

	/**
	 * Si on n'a pas de cible actuellement : 
	 * on recherche la cible hostile la plus proche
	 */
	actionSeek: function() {
		var oTarget = this.getTarget();
		if (!oTarget) {
			oTarget = this.getNearestVisibleHostileEntity();
			if (oTarget) {
				this.setTarget(oTarget);
				this.setMode('fight');
			}	
		}
		this.setThink('wait');
	},
	

	
	
	/**
	 * Permet le déplacement à l'angle et la vitesse spécifiée
	 * @param float a angle de déplacement
	 * @param float s vitesse
	 */
	actionWalk: function(a) {
		var oEntity = this.oEntity;
		oEntity.a = a;
		oEntity.setSpeedVector(a, oEntity.oBlueprint.speed);
		this.setThink('walk');
	},
	
	/**
	 * Stoppe le mouvement
	 */
	actionStop: function() {
		var oEntity = this.oEntity;
		oEntity.setSpeedVector(oEntity.a, 0);
		this.setThink('wait');
	},
	
	actionAim: function() {
		var oEntity = this.oEntity;
		var a;
		var oTarget = this.getTarget();
		if (oTarget && this.isEntityVisible(oTarget)) {
			a = this.getEntityAngle(oTarget);
			oEntity.setCourse(a);
			this.oGame.pushNetworkMessage(this.oGame.getClientEntities(), {m: 'ani', i: oEntity.getId(), a: 2});
		}
		this.setThink('wait');
	},
	
	
	/**
	 * Attack
	 */
	actionAttack: function() {
		var oEntity = this.oEntity;
		var oTarget = this.getTarget();
		if (oTarget) {
			a = this.getEntityAngle(oTarget);
			oEntity.setCourse(a);
			this.oGame.entityAttack(oEntity, 0);
		}
		this.setThink('wait');
	},
	
	/**
	 * Couick
	 */
	actionDie: function() {
		this.oEntity.setData('summoner', null);
		this.oEntity.bActive = false;
	},
	
	actionHold: function(n) {
		if (n > 0) {
			this.setMode('hold');
		} else {
			this.setMode('wander');
		}
	},
	
	
	
	/**
	 * Renvoie l'angle q'uil faut adopter pour viser la cible
	 */
	getEntityAngle: function(oTarget) {
		var oMe = this.oEntity;
		var fTheta = oMe.a;
		oTarget = oTarget || this.getTarget();
		if (oTarget !== null) {
			fTheta = Math.atan2(oTarget.y - oMe.y, oTarget.x - oMe.x);
			if (!this.isEntityVisible(oTarget)) { // cible invisible ou mobile aveuglé
				if (this.distanceTo(oTarget) >= this.MAX_INVISIBLE_DISTANCE) {
					return false;
				}
				fTheta += 6 * u.rand() - 3;
			}
			return fTheta;
		}
		return false;	
	},
	
	/**
	 * Renvoie true si le sujet peut voir la cible.
	 * pour que la fonction renvoie true il faut que le sujet puisse voir la cible
	 * ceci prend en compte l'invisibilité de la cible, 
	 * le niveau de detection et l'aveuglement du sujet,
	 * les obstacle muraux qui cacheraient éventuellement la cible
	 * @return bool
	 */
	isEntityVisible : function(oTarget) {
		if (oTarget === null) {
			return false;
		}
		var oMe = this.oEntity;
		var oTargetCreature = oTarget.getSoul();
		var oCreature = oMe.getSoul();
		if (!oCreature) {
			return false;
		}

		var bInvisible = oTargetCreature.getAttribute('invisible') > 0;
		var bEsp = oCreature.getAttribute('esp') > 0;
		var bBlind = oCreature.getAttribute('blind') > 0;
		
		var nMask = (bInvisible ? 4 : 0) | (bEsp ? 2 : 0) | (bBlind ? 1 : 0);
		
		switch (nMask) {
			case 0: // all normal 
			case 2: // esp
			case 6: // esp and target invisible
				var xTarget = oTarget.xSector;
				var yTarget = oTarget.ySector;
				var xMe = oMe.xSector;
				var yMe = oMe.ySector;
				return !Bresenham.line(xMe, yMe, xTarget, yTarget, this.testWalkable.bind(this));
				
			default:
				return false;
		}
	},

	testWalkable: function(x, y) {
		return !this.oGame.isWalkable(x, y);
	},

	/**
	 * Renvoie la cible prédédemment sélectionnée avec
	 * vérification de sa vie si la cible est détruite, renvoie
	 * null
	 */
	getTarget : function() {
		if (this._oTarget && (this._oTarget.bActive === false || this._oTarget.getSoul().getAttribute('dead') > 0)) {
			this._oTarget = null;
		}
		return this._oTarget;
	},
	
	/**
	 * Définit la nouvelle cible à abattre
	 * @param oTarget Entity
	 */
	setTarget: function(oTarget) {
		this._oTarget = oTarget;
	},
	
	/**
	 * Renvoie true si la cible est hostile
	 * @param oTarget
	 * @returns bool
	 */
	isEntityHostile: function(oTarget) {
		var oMe = this.oEntity;
		var oCreature = oMe.getSoul();
		var bConfused = oCreature.getAttribute('confused') > 0;
		var oMaster = oMe.getData('charmer') || oMe.getData('summoner'); 
		if (oMaster == oTarget) {
			return bConfused;
		}
		var nMyFaction = oMe.getData('faction');
		if (nMyFaction) {
			return bConfused || (nMyFaction !== oTarget.getData('faction'));
		} else {
			return true;
		}
	},
	
	/**
	 * Return true if the entity is old enought
	 * Freshly connected player should not be attacked
	 * This is not fair play
	 * @param oTarget Tested Entity
	 * @return bool 
	 */
	isEntityOldEnough: function(oTarget) {
		if (oTarget.getType() === CONST.ENTITY_TYPE_PLAYER) {
			var nCreationTime = oTarget.getData('creationTime') | 0;
			return this.oGame.getTime() - nCreationTime > 4;
		} else {
			return true;
		}
	},


	/**
	 * Renvoie la distance séparant le mob de sa cible si la
	 * cible est détruite, la distance renvoyé est -1
	 * @param oTarget Entity 
	 * @return float
	 */
	distanceTo: function(oTarget) {
		if (oTarget) {
			var oEntity = this.oEntity;
			return u.distance(oEntity.x, oEntity.y, oTarget.x, oTarget.y);
		} else {
			return -1;
		}
	},
	
	/**
	 * Recherche la cible la plus proche.
	 * - critère de distance
	 * - critère de faction
	 * - critère d'angle
	 */
	getNearestVisibleHostileEntity: function() {
		var i, oMob, oMe = this.oEntity;
		var nMaxDistance = this.MAX_VISIBLE_DISTANCE;
		var h = this.oGame.getAreaEntities([CONST.ENTITY_TYPE_PLAYER, CONST.ENTITY_TYPE_MOB], oMe.x, oMe.y, nMaxDistance);
		var n = h.length;
		for (i = 0; i < n; ++i) {
			oMob = h[i];
			if (oMob == oMe) {
				continue;
			}
			// check faction, visibility, distance
			if (oMob) {
				if (this.isEntityOldEnough(oMob) && 
					this.isEntityHostile(oMob) && 
					this.isEntityVisible(oMob) && 
					this.distanceTo(oMob) < nMaxDistance					
				) {
					return oMob;
				}
			}
		}
		// no mob
		return null;
	},

});

module.exports = CreatureThinker;
