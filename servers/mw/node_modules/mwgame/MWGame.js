var O2 = require('o2');

var Client = require('./Client.js');
var Instance = require('./Instance.js');
var Mediator = require('mediator');
var Debuggy = require('./Debuggy.js');

var ModChests = require('ModChests');
var ModEmporium = require('ModEmporium');
var ModMagic = require('ModMagic');
var ModAITwinker = require('ModAITwinker');

var OtherMods = require('./pluginLoader.js');

O2.createClass('MWGame', {

	_aClients : null, // Liste des clients connecté au jeu
	_nLastClientId : 0, // identifiant du dernier client
	_aInstances : null, // collection de Instances actuellement ouverte
	_nLastInstanceId : 0, // identifiant du dernier client

	_oMediator : null,
	_oDebuggy: null,

	_nTimeMod : 0, // sert à calculer le moment de transmettre les données de
					// changement d'état des entité
	UPDATE_PERIOD : 100, // 10 mise à jour max de changement d'état
	TIME_FACTOR : 40,

	onInstanceStateChanged : null,
	onInstanceSoulChanged : null,
	
	_aConnectionLog: null,

	__construct : function() {
		this._oDebuggy = new Debuggy();
		this._oDebuggy.bActive = true;
		this._aClients = [];
		this._aInstances = [];
		this._aConnectionLog = [];
		var m = new Mediator.Mediator();
		m.setApplication(this);
		this._oMediator = m;
		m.addPlugin(new ModChests());
		m.addPlugin(new ModEmporium());
		m.addPlugin(new ModMagic());
		m.addPlugin(new ModAITwinker());
		for (var sMod in OtherMods) {
			m.addPlugin(new OtherMods[sMod]());
		}
	},

	sendSignal : function(sSignal, oInstance, oParams) {
		this._oMediator.sendSignal(sSignal, oInstance, oParams);
	},
	
	/**
	 * Connecte un nouveau client et renvoie son identifiant
	 * 
	 * @param string
	 *            sName pseudo du client
	 * @return int identifiant numerique
	 */
	connectClient : function(sName, oSocket) {
		var c = new Client();
		c.setName(sName);
		c.setSocket(oSocket);
		var id = ++this._nLastClientId;
		c.setId(id);
		this._aClients[id] = c;
		return id;
	},

	/**
	 * Déconnecte un client du jeu
	 * 
	 * @param id
	 *            id client
	 */
	disconnectClient : function(cid) {
		this.leaveInstance(cid);
		var oClient = this._aClients[cid];
		var dConnect = oClient.getConnectionTime();
		var dDisc = new Date();
		this._aConnectionLog.push([oClient.getName(), dConnect.getTime(), dDisc.getTime()]);
		this._aClients[cid] = null;
		return cid;
	},

	/**
	 * Renvoie le client connecté à partir de l'identifant spécifié
	 * 
	 * @param cid
	 *            identifiant client
	 * @return Client
	 */
	getClient : function(cid) {
		if (this._aClients[cid]) {
			return this._aClients[cid];
		} else {
			throw new Error('client #' + cid + ' not found');
		}
	},

	/**
	 * Renvoie l'instance de partie dont l'id est spécifié
	 * @param gid id instance
	 * @return Instance
	 */
	getInstance : function(gid) {
		if (this._aInstances[gid]) {
			return this._aInstances[gid];
		} else {
			throw new Error('instance #' + gid + ' not found');
		}
	},

	/**
	 * Creation d'une partie
	 * @param string sInstance nom du jeu / fichier de donnée à charger
	 */
	createInstance : function(sInstance, oConfig, id) {
		var sMap = oConfig.map;
		var g;
		if (id) {
			g = this._aInstances[id];
			g.reset();
		} else {
			g = new Instance();
			id = ++this._nLastInstanceId;
			g.setId(id);
			this._aInstances[id] = g;
		}
		g.loadData(sMap);
		g.setName(sInstance);
		g.onSignal = this.sendSignal.bind(this);
		this.sendSignal('instanceCreated', g, {c: oConfig});
		return g;
	},
	
	

	/**
	 * Connecte le client à une partie en cours
	 * 
	 * @param cid identifiant client
	 * @param gid identifiant de la partie
	 * @return bool succès de l'opération
	 */
	joinInstance : function(cid, gid) {
		var oInstance = this.getInstance(gid);
		if (oInstance) {
			var oClient = this.getClient(cid);
			oInstance.addClient(oClient);
			oInstance.createClientEntity(oClient, 'm_warlock', 'p1');
			return true;
		} else {
			return false;
		}
	},

	/**
	 * Déconnecte le client de l'instance a laquelle il était connecté
	 * 
	 * @param int
	 *            cid id client
	 */
	leaveInstance : function(cid) {
		var oClient = this.getClient(cid);
		var oInstance = oClient.getInstance();
		if (oInstance) {
			oInstance.destroyClientEntity(oClient);
			oInstance.removeClient(oClient);
		}
	},
	
	/**
	 * Basculer tout le monde en mode : "attendez ! je charge une autre partie"
	 */
	endInstance: function(oInstance) {
		this._aClients.forEach(function (c) {
			if (!!c) {
				if (c.getInstance() == oInstance) {
					this.leaveInstance(c.getId());
				}
			}
		}, this);
	},

	/**
	 * Un client a demandé à respawner
	 */
	respawnClient : function(cid) {
		var oClient = this.getClient(cid);
		var oInstance = oClient.getInstance();
		oInstance.respawnEntity(oClient.getEntity(), 'p1');
	},

	/**
	 * Pour chaque instance : Calculer les entités qui ont bougé ou changé
	 * d'état Transmission par callback
	 */
	process : function() {
		this._nTimeMod += this.TIME_FACTOR;
		var bNeedState = this._nTimeMod >= this.UPDATE_PERIOD;
		var ai;
		var nInst = this._aInstances.length;
		var oInstance;
		var aTerminated = null; // if one instance is terminating, this flag is set to true
		for (var iInst = 0; iInst < nInst; ++iInst) {
			oInstance = this._aInstances[iInst];
			if (!oInstance) {
				continue;
			}
			ai = oInstance.process(bNeedState);
			if (oInstance.isTerminated()) {
				if (aTerminated === null) {
					aTerminated = [];
				}
				aTerminated.push(oInstance);
			};
			if (ai && bNeedState && ('states' in ai) && ai.states.length) {
				this.doInstanceStateChanged(oInstance, ai.states);
			}
			if (ai && ('souls' in ai) && ai.souls.length) {
				this.doInstanceSoulChanged(oInstance, ai.souls);
			}
		}
		if (bNeedState) {
			this._nTimeMod -= this.UPDATE_PERIOD;
		}
		if (aTerminated) {
			aTerminated.forEach(function(oInst) {
				oInst.doEnd();
			}, this);
		}
	},

	doInstanceStateChanged : function(oInstance, oStates) {
		if (this.onInstanceStateChanged) {
			this.onInstanceStateChanged(oInstance, oStates);
		}
	},

	doInstanceSoulChanged : function(oInstance, oSouls) {
		if (this.onInstanceSoulChanged) {
			this.onInstanceSoulChanged(oInstance, oSouls);
		}
	},

	getStatus : function(a) {
		var oStatus = {};

		if (a.indexOf('clients') >= 0) {
			oStatus.clients = this._aClients.filter(function(x) {
				return !!x;
			}).map(function(oClient) {
				return oClient.getStatus();
			});
		}
		if (a.indexOf('instances') >= 0) {
			oStatus.instances = this._aInstances.filter(function(x) {
				return !!x;
			}).map(function(oInst) {
				return oInst.getStatus();
			});
		}
		if (a.indexOf('plugins') >= 0) {
			oStatus.plugins = Object.keys(this._oMediator.getPlugins());
		}
		return oStatus;
	},
	
	debugCommand: function(idClient, sMessage) {
		var oClient = this.getClient(idClient);
		var oEntity = oClient.getEntity();
		var oInstance = oClient.getInstance();
		this._oDebuggy.command(oInstance, oEntity, sMessage);
	}

});

module.exports = MWGame;
