/**
 * Un thinker de base pour toute entité qui bouge
 */
var O2 = require('o2');
var Thinker = require('./Thinker.js');
var CONST = require('../data/consts.js');

var xTonari = [ -1, 0, 1, -1, 0, 1, -1, 0, 1 ];
var yTonari = [ -1, -1, -1, 0, 0, 0, 1, 1, 1 ];
// donnée ciollisionnelles
var xCollisions = [0, 1, 0, -1];	// Tableau des collision
var yCollisions = [-1, 0, 1, 0];	// ...


var MoverThinker = O2.extendClass(Thinker, {
	
	_oEntityCollision: null,
	
	__construct: function() {
		O2.parent(this);
		this.setThink('move');
	},
	
	thinkMove: function() {
		this.computeWallCollision();
		this.slide();
		var oBumper = this.computeCollision();
		if (oBumper) {
			this.resolveCollision(oBumper);
		}
	},
	
	
	getEntityCollision: function() {
		return this._oEntityCollision;
	},
	
	
	/**
	 * Test si le mobile spécifié entre en collision avec un autre mobile
	 * @param nTrail allonge la zone de collision sur le dernier vecteur dx dy
	 * nTrail représente le nombre de tests qui seront effectué tout au long de ce vecteur
	 * Cela permet de gérer les mobilke a haute vitese
	 * @return mobile percuté, ou null si aucune collision
	 */
	computeCollision : function(nTrail) {
		var oEntity = this.oEntity;
		var aSector;
		var i;
		var oOther, iOther, nSectorLength;
		var oGame = this.oGame;
		var nSize = oGame.getMapSize();
		var x, y, dx = 0, dy = 0, iTrail;
		nTrail = nTrail || 0;
		if (nTrail) {
			dx = oEntity.dx / nTrail;
			dy = oEntity.dy / nTrail;
		}
		for (i = 0; i < 9; ++i) {
			x = oEntity.xSector + xTonari[i];
			y = oEntity.ySector + yTonari[i];
			if (x >= 0 && y >= 0 && x < nSize && y < nSize) {
				aSector = oGame.getMapBlockProp(x, y, 'entities');
			} else {
				continue;
			}
			nSectorLength = aSector.length;
			for (iOther = 0; iOther < nSectorLength; ++iOther) {
				oOther = aSector[iOther];
				if (oOther.getType() != CONST.ENTITY_TYPE_MISSILE && oOther != oEntity) {
					for (iTrail = 0; iTrail < nTrail; ++iTrail) { 
						if (oEntity.hits(oOther, dx * iTrail, dy * iTrail)) {
							return oEntity._oEntityCollision = oOther;
						}
					}
				}
			}
		}
		return oEntity._oEntityCollision = null;
	},

	computeWallCollision: function() {
		var oEntity = this.oEntity;
		var x = oEntity.x;
		var y = oEntity.y;
		var dx = oEntity.dx;
		var dy = oEntity.dy;

		var ix, iy;
		var bx = false;
		var by = false;
		
		// tester les secteurs

		var nSize = oEntity.getSize();
		var oGame = this.oGame;

		// calculer le cadran (point cardinal dominant dans lequel se déplace l'entity
		// permet d'eviter de se faire coincer le cul de chemise dans la porte qui se referme
		var nXYFormula = (Math.abs(dx) > Math.abs(dy) ? 1 : 0) | ((dx > dy) || (dx == dy && dx < 0) ? 2 : 0);

		for (var i = 0; i < 4; ++i) {
			if (nXYFormula == i) {
				continue;
			}
			ix = nSize * xCollisions[i] + x;
			iy = nSize * yCollisions[i] + y;
			if (oGame.clip(ix + dx, iy)) {
				bx = true;
				if (!oEntity.bSlideWall) {
					by = true;
				}
			}
			if (oGame.clip(ix, iy + dy)) {
				by = true;
				if (!oEntity.bSlideWall) {
					bx = true;
				}
			}
			if (bx && by) {
				var sm = -oEntity.fSpeedModifier;
				oEntity.move(dx * sm + x, dy * sm + y);
				break;
			}
		}
		if (bx || by) {
			this.bump(bx, by);
			oEntity.dx = bx ? 0 : dx;
			oEntity.dy = by ? 0 : dy;
		}
	},
	
	/**
	 * Verifie la collision contre les murs
	 */
	slide: function() {
		this.oEntity.slide();
	},
	
	bump: function(bx, by) {

	},
	
	/**
	 * Gestion des collision inter-mobile
	 * Il doit s'agir de deux non-missiles
	 * Quand l'un percute l'autre, on applique un retour arrière pour ne pas que les mobile se chevauchent
	 */
	resolveCollision: function(oTarget) {
		oSubject = this.oEntity;
		if (oTarget.getType() != CONST.ENTITY_TYPE_MISSILE) {
			oSubject.rollbackXY();
			// augmenter la distance entre les mobiles qui collisionnent
			var xme = oSubject.x;
			var yme = oSubject.y;
			var xmo = oTarget.x;
			var ymo = oTarget.y;
			var dx = xme - xmo;
			var dy = yme - ymo;
			oSubject.slide(dy, dx);
		}
	},
});

module.exports = MoverThinker;
