/**
 * Classe de construction d'un niveau à partir de données brutes issues d'un générateur
 * La classe accepte ...
 *  - un tableau à deux dimensions composé de codes logiques
 *  - une palette associant les codes logiques à des codes physiques
 *  - des références à des textures
 */

var fs = require('fs');
var BLOCK = require('./data/blocks.js');
var VISUALS = require('./data/visuals.js');
var PALETTES = require('./data/palettes.js');
var MAPS = require('./data/maps.js');
var LEVELS = {};



/**
 * Ajoute une carte.
 * Généralement les données spécifié sont lue à partir d'un fichier JSON externe
 * @param sMap nom de la carte
 * @param oMap données de la carte
 */
function setMap(sMap, oMap, sPalette, sVisual) {
	MAPS[sMap] = {
		map: oMap,
		palette: PALETTES[sPalette],
		visual: VISUALS[sVisual]
	};
}


function setVisual(sVis, oVis) {
	VISUALS[sVis] = oVis;
}

function setPalette(sPal, oPal) {
	PALETTES[sPal] = oPal;
}



/**
 * Chargement d'une map
 * Génération du JSON a destination du raycaster
 * @param sMap nom de la map
 * @retur object
 */
function load(sMap) {
	if (sMap in LEVELS) {
		return LEVELS[sMap];
	}
	if (sMap in MAPS) {
		var m = MAPS[sMap].map;
		var c = MAPS[sMap].palette;
		var x, y, mxy, nTag;
		var n = m.length;
		var r, v;
		
		var oWalls = [];
		var oFlats = [];
		var l = LEVELS[sMap] = {};
		l.map = [];
		
		// indexation des codes de la palette
		var i = 0;
		for (var pn in c.blocks) {
			c.blocks[pn].i = i; // ajout de l'indice
			oWalls[i] = c.blocks[pn].w; // enregistrement du mur
			oFlats[i] = c.blocks[pn].f; // enrigistrement sol/plafond
			++i;
		}
		// parcourir la carte
		var cmxy, nObj, nPos, xObj, yObj;
		var aTags = [];
		var aObjects = [];
		for (y = 0; y < n; ++y) {
			r = [];
			for (x = 0; x < n; ++x) {
				mxy = m[y][x] & 0xFF;
				nTag = (m[y][x] & 0xFF00) >> 8;
				nObj = (m[y][x] & 0xFF0000) >> 16;
				nPos = (m[y][x] & 0xFF000000) >> 24;
				// composer le code physique
				if (!(mxy in c.blocks)) {
					throw new Error('map does not contain this code : 0x' + mxy.toString(16));
				}
				cmxy = c.blocks[mxy];
				v = cmxy.i | (cmxy.c << 8) | (cmxy.o << 16);
				r.push(v);
				// tag
				if (nTag) {
					aTags.push({
						x: x,
						y: y,
						tag: c.tags[nTag]
					});					
				}
				// objects
				if (nObj) {

				}
			}
			l.map.push(r);
		}
		l.walls = {
			src: c.walls,
			codes: oWalls
		};
		l.flats = {
			src: c.flats,
			codes: oFlats
		};
		l.background = c.background;
		l.tiles = {};
		l.blueprints = [];
		l.visual = MAPS[sMap].visual;
		l.startpoint = {
			x: 3 * 64,
			y: 3 * 64,
			angle: 0
		};
		l.objects = [];
		l.tags = aTags;
		return l;
	} else {
		throw new Error('Mapper : map ' + sMap + ' not found');
	}
}


function load2(sMap) {
	if (sMap in LEVELS) {
		return LEVELS[sMap];
	}
	var l = LEVELS[sMap] = {};
	var oData = JSON.parse(fs.readFileSync(__dirname + '/data/maps/' + sMap));

	l.map = [];
	var m = oData.map;
	var c = oData.palette;
	
	var oWalls = [];
	var oFlats = [];
	// indexation des codes de la palette
	var i = 0;
	for (var pn in c.blocks) {
		c.blocks[pn].i = i; // ajout de l'indice
		oWalls[i] = c.blocks[pn].w; // enregistrement du mur
		oFlats[i] = c.blocks[pn].f; // enrigistrement sol/plafond
		++i;
	}
	var x = 0, y = 0, mxy, cmxy, v, n = oData.map.length;

	for (y = 0; y < n; ++y) {
		r = [];
		for (x = 0; x < n; ++x) {
			mxy = m[y][x] & 0xFF;
			// composer le code physique
			if (!(mxy in c.blocks)) {
				throw new Error('map does not contain this code : 0x' + mxy.toString(16));
			}
			cmxy = c.blocks[mxy];
			v = cmxy.i | (cmxy.c << 8) | (cmxy.o << 16);
			r.push(v);
		}
		l.map.push(r);
	}
	
	if ('uppermap' in oData) {
		m = oData.uppermap;
		l.uppermap = [];
		for (y = 0; y < n; ++y) {
			r = [];
			for (x = 0; x < n; ++x) {
				mxy = m[y][x] & 0xFF;
				// composer le code physique
				if (!(mxy in c.blocks)) {
					throw new Error('map does not contain this code : 0x' + mxy.toString(16));
				}
				cmxy = c.blocks[mxy];
				v = cmxy.i | (cmxy.c << 8) | (cmxy.o << 16);
				r.push(v);
			}
			l.uppermap.push(r);
		}
	}
	
	
	l.visual = oData.visual;
	l.walls = {
		src: 'resources/gfx/textures/' + c.walls + '.png',
		codes: oWalls
	};
	l.flats = {
		src: 'resources/gfx/textures/' + c.flats + '.png',
		codes: oFlats
	};
	l.background = 'resources/gfx/textures/' + c.background + '.png';
	l.tiles = {};
	l.blueprints = [];
	l.visual = oData.visual;
	l.startpoint = {
		x: oData.startpoint.x,
		y: oData.startpoint.y,
		angle: oData.startpoint.angle,
	};
	l.objects = oData.objects;
	l.tags = oData.tags;
	return l;
}

module.exports = {
	BLOCK: BLOCK,
	load: load,
	load2: load2,
	setMap: setMap,
	setVisual: setVisual,
	setPalette: setPalette
};
