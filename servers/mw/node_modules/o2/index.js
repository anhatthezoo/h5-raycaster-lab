/** O2: Fonctionalités Orientées Objets pour Javascript
 * 2010 Raphaël Marandet
 * ver 1.0   10.10.2010
 * ver 1.1   28.04.2013 : ajout d'un support namespace  
 * ver 2.0   25.01.2014 : transformation pour node js 
 * var 2.1   14.02.2014 : classes anonymes
 * ver 3.0   20.02.2015 : changement pour node js : nouvelle facon d'appeler un parent
 */

/** Invoque la methode parente
 * @param This appelant, + Paramètres normaux de la methode parente.
 * @return Retour normal de la methode parente.
 */
function __inheritedCaller() {
	var fCaller = __inheritedCaller.caller;
	var oThis = arguments[0];
	var aParams;
	if ('__inherited' in fCaller) {
		aParams = Array.prototype.slice.call(arguments, 1);
		return fCaller.__inherited.apply(oThis, aParams);
	} else {
		throw new Error('o2: no __inherited');
	}
}

/** Creation d'une nouvelle classe
 * @example NouvelleClasse = Function.createClass(function(param1) { this.data = param1; });
 * @param fConstructor prototype du constructeur
 * @return Function
 */
function createClass(pPrototype) {
	var f;
	f = function() {
		if ('__construct' in this) {
			this.__construct.apply(this, arguments);
		}
	};
	if (pPrototype === undefined) {
		return f;
	} else if (typeof pPrototype === 'object') {
		return extendPrototype(f, pPrototype);
	} else {
		return null;
	}
};


/** Mécanisme d'extention de classe.
 * Cette fonction accepte un ou deux paramètres
 * Appel avec 1 paramètre :
 * @param Définition de prototype à ajouter à la classe.
 * Appel avec 2 paramètres :
 * @param Classe parente
 * @param Définition de prototype à ajouter à la classe.
 * @return Instance de lui-même.
 */
function extendPrototype(pParent, aDefinition) {
	var iProp = '', f, fInherited;
	if (aDefinition instanceof Function) {
		aDefinition = aDefinition.prototype;
	}
	for (iProp in aDefinition) {
		f = aDefinition[iProp];
		if (iProp in pParent.prototype && (pParent.prototype[iProp] instanceof Function)) {
			// Sauvegarde de la méthode en cours : elle pourrait être héritée
			fInherited = pParent.prototype[iProp];
			// La méthode en cour est déja présente dans la super classe
			if (f instanceof Function) {
				// completion des __inherited
				pParent.prototype[iProp] = f;
				pParent.prototype[iProp].__inherited = fInherited;
			} else {
				// On écrase probablement une methode par une propriété : Erreur
				throw new Error('o2: method ' + iProp + ' overridden by property.');
			}
		} else {
			// Ecrasement de la propriété
			pParent.prototype[iProp] = aDefinition[iProp];
		}
	}
	return pParent;
};

/** Mécanisme d'extension de classe
 * @param Parent Nom de la classe Parente
 * @param X prototype du constructeur (optionnel)
 * @param Y prototype de la classe étendue
 */
function extendClass(Parent, X) {
	return extendPrototype(extendPrototype(createClass(), Parent), X);
};

/**
 * Creation d'un objet
 * Le nom de l'objet peut contenir des "." dans ce cas de multiple objets sont créés
 * ex: O2.createObject("MonNamespace.MaBibliotheque.MaClasse", {...});
 * var créer un objet global "MonNamespace" contenant un objet "MaBibliotheque" contenant lui même l'objet "MaClasse"
 * ce dernier objet recois la définition du second paramètre.
 *  
 * 
 * @param sName nom de l'objet
 * @param oObject objet
 * @param object
 */
function createObject(sName, oObject) {
	var aName = sName.split('.');
	var sClass = aName.pop();
	var pIndex = global;
	var sNamespace;
	while (aName.length) {
		sNamespace = aName.shift();
		if (!(sNamespace in pIndex)) {
			pIndex[sNamespace] = {};
		}
		pIndex = pIndex[sNamespace];
	}
	if (!(sClass in pIndex)) {
		pIndex[sClass] = oObject;
	} else {
		for ( var sProp in oObject) {
			pIndex[sClass][sProp] = oObject[sProp];
		}
	}
	return oObject;
}

/** 
 * Charger une classe à partir de son nom - le nom suit la syntaxe de la fonction O2.createObject() concernant les namespaces. 
 * @param s string, nom de la classe
 * @return pointer vers la Classe
 */
function loadObject(s) {
	var aClass = s.split('.');
	var pBase = window;
	while (aClass.length > 1) {
		pBase = pBase[aClass.shift()];
	}
	var sClass = aClass[0];
	return pBase[sClass];
};

/** Creation d'une classe avec support namespace
 * le nom de la classe suit la syntaxe de la fonction O2.createObject() concernant les namespaces.
 * @param sName string, nom de la classe
 * @param pPrototype définition de la nouvelle classe
 */
function createClassNS(sName, pPrototype) {
	if (sName) {
		return createObject(sName, createClass(pPrototype));
	} else {
		return createClass(sName);
	}
};

/** Extend d'un classe
 * le nom de la nouvelle classe suit la syntaxe de la fonction O2.createObject() concernant les namespaces.
 * @param sName string, nom de la nouvelle classe
 * @param pParent string|object Classe parente
 * @param pPrototype Définition de la classe fille  
 */
function extendClassNS(sName, pParent, pPrototype) {
	if (sName) {
		if (typeof pParent === 'string') {
			pParent = loadObject(pParent);
		}
		return createObject(sName, extendClass(pParent, pPrototype));
	} else {
		return extendClass(pParent, pPrototype);
	}
};


module.exports = {
	parent: __inheritedCaller,
	createObject: createObject,
	createClass: createClassNS,
	extendClass: extendClassNS
};
