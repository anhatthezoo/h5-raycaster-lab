var O2 = require('o2');

O2.createClass('ADV.EffectProcessor', {
	
	_aEffects: null,
	_nTime: 0,
	
	__construct: function() {
		this.reset();
	},
	
	/**
	 * Applique un effet
	 * l'effet doit etre renseigné au niveau de la ciblet et de la source
	 * et tous le reste
	 */
	applyEffect: function(oEffect) {
		var oSoul = oEffect.getTarget().getSoul();
		if (oEffect.accept(this)) {
			if (oEffect.getDurationType() <= 1) {
				oEffect._nExpirationTime = this._nTime + oEffect.getDuration();
				this._aEffects.push(oEffect);
				oSoul._aEffects.push(oEffect);
			}
			oEffect.cast(this);
			return true;
		} else {
			return false;
		}
	},
	
	/**
	 * Joue l'expiration d'un effet
	 * @param e Effet
	 */
	expireEffect: function(e) {
		e.expire(this);
		var aSoulEffects = e.getTarget().getSoul()._aEffects;
		var nIndex = aSoulEffects.indexOf(e);
		if (nIndex >= 0) {
			aSoulEffects.splice(nIndex, 1);
		}
	},
	
	reset: function() {
		this._aEffects = [];
		this._nTime = 0;
	},
	
	/**
	 * Elimine immédiatement tous les effet qui ont expiré/
	 * utilise expireEffect pour que l'effet se termine proprement
	 */
	removeDeadEffects: function() {
		this._aEffects = this._aEffects.filter(function(e) {
			if (e.isExpired(this._nTime)) {
				this.expireEffect(e);
				return false;
			} else {
				return true;
			}
		}, this);
	},
	
	/**
	 * Elimine les effets d'une entité qui va etre détruite,
	 * de manière a ce que l'expiration de ces effets ne se fasse pas alors que l'entité target est détruite
	 */
	removeEffectsOfDeadEntity: function(oTarget) {
		this._aEffects = this._aEffects.filter(function(e) {
			if (e.getTarget() == oTarget || e.getSource() == oTarget) {
				this.expireEffect(e);
				return false;
			} else {
				return true;
			}
		}, this);
	},
	
	/**
	 * Supprime instantanément tous les effets non-naturel de l'entité
	 * @param oEntity entité a qui on supprime les effets
	 * @param bEntityIsLeaving boolean indiquant que l'entité va quitter l'instance
	 * la totalité des effet qui lui sont appliqué ainsi que la totalité des effet
	 * que cette entité a produit sur les autre entité doivent disparaitre
	 */
	stripEffects: function(oEntity, bEntityIsLeaving) {
		oEntity.getSoul()._aEffects.forEach(function(e) {
			if (bEntityIsLeaving || (!e.hasTag('innate'))) {
				e.dispel();
			}
		});
		if (bEntityIsLeaving) {
			this._aEffects.forEach(function(e) {
				if (e.getSource() == oEntity) {
					e.dispel();
				}
			});
		}
		this.removeDeadEffects();
	},

	/**
	 * Joue periodiquement la lmethode run de chaque effet
	 * Elimine les effet qui ont expiré
	 */
	processEffects: function() {
		var nTime = ++this._nTime;
		var ep = this;
		this.removeDeadEffects();
		this._aEffects.forEach(function(e) {
			e.run(ep);
		});
	}
});

module.exports = ADV.EffectProcessor;
