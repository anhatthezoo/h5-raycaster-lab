var O2 = require('o2');
var CONST = require('./data/consts.js');


/**
 * Entité circulant dans le labyrinthe
 * Caractérisée par une position, un angle et deux vitesse de translation
 * une pour chaque axe
 */
O2.createClass('Entity', {
	id: -1,
	
	sBlueprint: '', // indication sur le blueprint
	oBlueprint: null,
	
	fSpeedModifier: 1,
	
	x: 0,
	y: 0,
	a: 0,
	ma: 0,
	ms: 0,
	dx: 0,
	dy: 0,
	xSector: -1,
	ySector: -1,

	xSave: 0,
	ySave: 0,
	
	nSize: 0,
	
	nPlaneSpacing: 64,
	
	nCreationTime: 0, // game time of creation

	// évènements
	onLeaveSector: null,
	onEnterSector: null,

	// attributs physique pris en compte lors du déplacement
	bActive: true,		// actif, pris en compte lors du processing de horde
	bEthereal: false,	// traverse les mobiles mais pas les murs.
	bInstable: false,	// explose au contact d'un mobile ou d'un mur. comme c'est le cas pour les missile.
	bSlideWall: true,  // l'entité glisse contre les murs en cas de collision avec un mur
	bBouncing: false, // l'entity rebondi contre les murs

	nIdOwner: null,		// identifiant du propriétaire s'il y en a un
	nIdFaction: 0,		// identifiant faction (0 = faction hostile pour tous)
	nSectorCode: 0,		// code du secteur actuellement traversé. lorsque ce code change, un évènement est déclenché
	
	
	// game data
	// variables concernant le jeu
	sName: '',
	oData: null,
	
	oThinker: null,
	
	bStateChanged: true,
	oState: null,
	
	nLastUpdateTime: 0,
	
	
	__construct: function() {
		this.oWallCollision = {x: 0, y: 0};
		this.oData = {};
		this.oState = {};
	},
	
	getId: function() {
		return this.id;
	},
	
	setCreationTime: function(nTime) {
		this.nCreationTime = nTime;
	},
	
	getCreationTime: function() {
		return this.nCreationTime;
	},
	
	setName: function(sName) {
		return this.sName = sName;
	},
	
	getName: function() {
		return this.sName;
	},
	
	/**
	 * Renvoie le type de l'entité
	 * @return int
	 */
	getType: function() {
		return this.oBlueprint.type;
	},
	
	getSize: function() {
		return this.nSize;
	},
	
	/**
	 * Définition du thinker
	 */
	setThinker: function(t) {
		if (t) {
			this.oThinker = t;
			t.setEntity(this);
		} else if (this.oThinker) {
			this.oThinker.setEntity(null);
			this.oThinker = null;
		}
	},
	
	getThinker: function() {
		return this.oThinker;
	},
	
	/**
	 * Définition de données relatives au jeu
	 * Ces donnée peuvent etre variable en fonction du type de jeu
	 */
	setData: function(sVar, xVal) {
		this.oData[sVar] = xVal;
	},
	
	/**
	 * Interrogation de données relatives au jeu
	 * Ces donnée peuvent etre variable en fonction du type de jeu
	 */
	getData: function(sVar) {
		if (sVar in this.oData) {
			return this.oData[sVar];
		} else {
			return null;
		}
	},
	
	
	/**
	 * Renvoie l'instance Soul planquée dans les data
	 * @return Soul
	 */
	getSoul: function() {
		return this.getData('soul');
	},
	
	/**
	 * Enregistre le timestamp de la dernière mise à jour de la position
	 * de cette entité.
	 * s'il s'avère que le delai entre le précedent timestamp est trop 
	 * important, on provoque un changement d'état qui se traduira par 
	 * l'envoie des données de cette entité à tous les clients.
	 * @param int t timestamp
	 */ 
	updateTime: function(t) {
		if ((t - this.nLastUpdateTime) > CONST.ENTITY_UPDATE_DELAY) {
			this.bStateChanged = true;
		}
		this.nLastUpdateTime = t;
	},
	
	/**
	 * Modification de l'angle de visée
	 * @param float a nouvel angle
	 */
	setViewAngle: function(a) {
		if (a != this.a) {
			this.bStateChanged = true;
			this.a = a;
		}
	},
	
	/**
	 * Renvoie l'angle de visée
	 * @return float
	 */
	getViewAngle: function() {
		return this.a;
	},
	
	/**
	 * Renvoie true si l'entité est active
	 * @return bool
	 */
	isActive: function() {
		return this.bActive;
	},

	
	/**
	 * L'entité se déplace selon ses vitesse dx dy
	 */
	slide: function() {
		var sm = this.fSpeedModifier;
		this.move(this.dx * sm + this.x, this.dy * sm + this.y);
	},

	/**
	 * Change l'angle de déplacement et l'angle de vue
	 */
	setCourse: function(a) {
		if (this.ma != a || this.a != a) {
			this.ma = a;
			this.a = a;
			this.dx = Math.cos(a) * this.ms; 
			this.dy = Math.sin(a) * this.ms;
			this.bStateChanged = true;
		}
	},
	
	/**
	 * Changement des vecteurs de vitesse
	 * @param ma Moving angle
	 * @param ms Moving speed
	 */
	setSpeedVector: function(ma, ms) {
		if (this.ma != ma || this.ms != ms) {
			this.ma = ma;
			this.ms = ms;
			this.dx = Math.cos(ma) * ms; 
			this.dy = Math.sin(ma) * ms;
			this.bStateChanged = true;
		}
	},
	
	/**
	 * Déplacement à la position spécifiée
	 * @param x ...
	 * @param y nouvelles coordonnées
	 */
	move: function(x, y) {
		this.x = x;
		this.y = y;
		this.changeSector();
	},
	
	changeSector: function() {
		var ps = this.nPlaneSpacing;
		var xSector = this.x / ps | 0;
		var ySector = this.y / ps | 0;

		if (xSector != this.xSector || ySector != this.ySector) {
			// changer de secteur
			this.doLeaveSector();
			this.xSector = xSector;
			this.ySector = ySector;
			this.doEnterSector();
		}
	},
	
	/**
	 * L'entité vit sa vie
	 */
	process: function() {
		if (this.isActive()) {
			this.saveXY();
			if (this.oThinker) {
				this.oThinker.think();
			}
		} else {
			g.destroyEntity(oEntity.id);
		}
	},



	
	/**
	 * Indique si l'état de l'entité à changé depuis le dernier appel à cette fonction.
	 * Renvoie le flag StateChange qui indique la nécessité de transmettre le changement d'état à qui de droit.
	 * @return bool
	 */
	isStateChanged: function() {
		var b = this.bStateChanged;
		this.bStateChanged = false;
		return b;
	},
	
	/**
	 * Renvoie un état de l'entité
	 */
	getState: function() {
		var s = this.oState;
		s.i = this.id;
		s.a = this.a;
		s.x = this.x;
		s.y = this.y;
		s.ma = this.ma;
		s.ms = this.ms;
		s.sm = this.fSpeedModifier;
		return s;
	},

	////// EVENTS ////// EVENTS ////// EVENTS ////// EVENTS ////// EVENTS //////
	////// EVENTS ////// EVENTS ////// EVENTS ////// EVENTS ////// EVENTS //////
	////// EVENTS ////// EVENTS ////// EVENTS ////// EVENTS ////// EVENTS //////
	////// EVENTS ////// EVENTS ////// EVENTS ////// EVENTS ////// EVENTS //////
	////// EVENTS ////// EVENTS ////// EVENTS ////// EVENTS ////// EVENTS //////
	////// EVENTS ////// EVENTS ////// EVENTS ////// EVENTS ////// EVENTS //////

	/**
	 * Ce qu'il se passe lorsque l'entité sort d'un secteur
	 */
	doLeaveSector: function() {
		if (this.onLeaveSector) {
			this.onLeaveSector(this, this.xSector, this.ySector);
		}
	},

	/**
	 * Ce qu'il se passe lorsque l'entité entre dans un secteur
	 */
	doEnterSector: function() {
		if (this.onEnterSector) {
			this.onEnterSector(this, this.xSector, this.ySector);
		}
	},

	/** 
	 * Test de collision avec l'entité spécifiée
	 * @param oEntity entité susceptible d'entrer en collision
	 * @param xTrail et yTrail permette d'allonger la zone collision
	 * ce qui permet de traiter avec les projectile rapide
	 * @returnn bool
	 */
	hits: function(oEntity, xTrail, yTrail) {
		if (this.bEthereal || oEntity.bEthereal) {
			return false;
		}
		xTrail = xTrail || 0;
		yTrail = yTrail || 0;
		var dx = oEntity.x - this.x - xTrail;
		var dy = oEntity.y - this.y - yTrail;
		var d2 = dx * dx + dy * dy;
		var dMin = this.nSize + oEntity.nSize;
		dMin *= dMin;
		return d2 <= dMin;
	},
	
	
	rollbackXY: function() {
		this.move(this.xSave, this.ySave);
	},
	
	saveXY: function() {
		this.xSave = this.x;
		this.ySave = this.y;
	},
	
});

module.exports = Entity;
